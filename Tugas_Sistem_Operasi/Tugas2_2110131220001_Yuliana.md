# Laporan Tugas Sistem Operasi
<img src="/Logo-ULM.png" width="20%" height="20%">

Mata Kuliah | Sistem Operasi
--------|--------
Nim | 2110131220001
Nama | Yuliana

## **Tugas Menterjemahkan**

![Cover](https://user-images.githubusercontent.com/112523858/189241937-21c87048-6fd4-43ad-ab22-eec204334781.JPG)

_**Daftar Isi**_
<br>BAB 1 PENDAHULUAN
- 1.1 APA ITU SISTEM OPERASI?
    - 1.1.1 Sistem Operasi sebagai Mesin yang Diperluas
    - 1.1.2 Sistem Operasi sebagai Manajer Sumber Daya
- 1.2 SEJARAH SISTEM OPERASI
    - 1.2.1 Generasi Pertama (1945–55): Tabung Vakum
    - 1.2.2 Generasi Kedua (1955–65): Transistor dan Sistem Batch
    - 1.2.3 Generasi Ketiga (1965–1980): IC dan Multiprogramming
    - 1.2.4 Generasi Keempat (1980–Sekarang): Komputer Pribadi
    - 1.2.5 Generasi Kelima (1990–Sekarang): Komputer Bergerak
- 1.3 TINJAUAN PERANGKAT KERAS KOMPUTER
    - 1.3.1 Prosesor
    - 1.3.2 Memori
    - 1.3.3 Disk
    - 1.3.4 Perangkat I/O
    - 1.3.5 Bus
    - 1.3.6 Mem-boot Komputer
- 1.4 ZOO SISTEM OPERASI
    - 1.4.1 Sistem Operasi Mainframe
    - 1.4.2 Sistem Operasi Server
    - 1.4.3 Sistem Operasi Multiprosesor
    - 1.4.4 Sistem Operasi Komputer Pribadi
    - 1.4.5 Sistem Operasi Komputer Genggam
    - 1.4.6 Sistem Operasi Tertanam
    - 1.4.7 Sistem Operasi Sensor-Node
    - 1.4.8 Sistem Operasi Real-Time
    - 1.4.9 Sistem Operasi Smart Card
- 1.5 KONSEP SISTEM OPERASI
    - 1.5.1 Proses
    - 1.5.2 Ruang Alamat
    - 1.5.3 File
    - 1.5.4 Masukan/Keluaran
    - 1.5.5 Perlindungan
    - 1.5.6 Kulitnya
    - 1.5.7 Ontogeni Merekapitulasi Filogeni
- 1.6 PANGGILAN SISTEM
    - 1.6.1 Panggilan Sistem untuk Manajemen Proses
    - 1.6.2 Panggilan Sistem untuk Manajemen File
    - 1.6.3 Panggilan Sistem untuk Manajemen Direktori
    - 1.6.4 Panggilan Sistem Lain-Lain
    - 1.6.5 Windows Win32 API
- 1.7 STRUKTUR SISTEM OPERASI
    - 1.7.1 Sistem Monolitik
    - 1.7.2 Sistem Berlapis
    - 1.7.3 Mikrokernel
    - 1.7.4 Model Server-Klien
    - 1.7.5 Mesin Virtual
    - 1.7.6 Exokernels
- 1.8 DUNIA MENURUT C
    - 1.8.1 Bahasa C
    - 1.8.2 File Header
    - 1.8.3 Proyek Pemrograman Besar
    - 1.8.4 Model Run Time 76
- 1.9 PENELITIAN SISTEM OPERASI
- 1.10 GARIS BESAR DARI SELURUH BUKU INI
- 1.11 UNIT METRIK
- 1.12 RINGKASAN

# Bab 1
A modern computer consists of one or more processors, some main memory, disks, printers, a keyboard, a mouse, a display, network interfaces, and various other input/output devices. All in all, a complex system.oo If every application pro grammer had to understand how all these things work in detail, no code would ever get written. Furthermore, managing all these components and using them optimally is an exceedingly challenging job. For this reason, computers are equipped with a layer of software called the operating system, whose job is to provide user programs with a better, simpler, cleaner, model of the computer and to handle managing all the resources just mentioned. Operating systems are the subject of this book.

> _Komputer modern terdiri dari satu atau lebih prosesor, beberapa memori utama, disk, printer, keyboard, mouse, layar, antarmuka jaringan, dan berbagai perangkat input/output lainnya. Secara keseluruhan, sistem yang kompleks.oo Jika setiap programmer aplikasi harus memahami bagaimana semua hal ini bekerja secara detail, tidak akan ada kode yang bisa ditulis. Lebih jauh lagi, mengelola semua komponen ini dan menggunakannya secara optimal adalah pekerjaan yang sangat menantang. Untuk alasan ini, komputer dilengkapi dengan lapisan perangkat lunak yang disebut sistem operasi, yang tugasnya menyediakan program pengguna dengan model komputer yang lebih baik, lebih sederhana, lebih bersih, dan untuk menangani pengelolaan semua sumber daya yang baru saja disebutkan. Sistem operasi adalah pokok bahasan buku ini._

Most readers will have had some experience with an operating system such as Windows, Linux, FreeBSD, or OS X, but appearances can be deceiving. The program that users interact with, usually called the shell when it is text based and the GUI (Graphical User Interface)—which is pronounced ‘‘gooey’’—when it uses icons, is actually not part of the operating system, although it uses the operating system to get its work done.

> _Sebagian besar pembaca akan memiliki pengalaman dengan sistem operasi seperti Windows, Linux, FreeBSD, atau OS X, tetapi tampilan dapat menipu. Program yang berinteraksi dengan pengguna, biasanya disebut shell jika berbasis teks dan GUI (Graphical User Interface)—yang diucapkan "lengket"—saat menggunakan ikon, sebenarnya bukan bagian dari sistem operasi, meskipun ia menggunakan sistem operasi untuk menyelesaikan pekerjaannya._

A simple overview of the main components under discussion here is given in Figure. 1-1. Here we see the hardware at the bottom. The hardware consists of chips, boards, disks, a keyboard, a monitor, and similar physical objects. On top of the hardware is the software. Most computers have two modes of operation: kernel mode and user mode. The operating system, the most fundamental piece of software, runs in kernel mode (also called supervisor mode). In this mode it has complete access to all the hardware and can execute any instruction the machine is capable of executing. The rest of the software runs in user mode, in which only a subset of the machine instructions is available. In particular, those instructions that affect control of the machine or do I/O )Input/Output" are forbidden to user-mode programs. We will come back to the difference between kernel mode and user mode repeatedly throughout this book. It plays a crucial role in how operating systems work.

> _Gambaran sederhana dari komponen utama yang dibahas di sini diberikan pada Gambar 1-1. Di sini kita melihat perangkat keras di bagian bawah. Perangkat keras terdiri dari chip, papan, disk, keyboard, monitor, dan benda fisik serupa. Di atas perangkat keras adalah perangkat lunak. Sebagian besar komputer memiliki dua mode operasi: mode kernel dan mode pengguna. Sistem operasi, bagian paling mendasar dari perangkat lunak, berjalan dalam mode kernel (juga disebut mode supervisor). Dalam mode ini memiliki akses lengkap ke semua perangkat keras dan dapat mengeksekusi instruksi apa pun yang mampu dijalankan oleh mesin. Sisa perangkat lunak berjalan dalam mode pengguna, di mana hanya sebagian dari instruksi mesin yang tersedia. Secara khusus, instruksi yang mempengaruhi kontrol mesin atau melakukan I/O )Input/Output" dilarang untuk program mode pengguna. Kami akan kembali ke perbedaan antara mode kernel dan mode pengguna berulang kali di seluruh buku ini. peran penting dalam cara kerja sistem operasi._

<img src="/Gambar1-1.JPG" width="75%" height="75%">

Gambar 1-1. Di mana sistem operasi cocok.

The user interface program, shell or GUI, is the lowest level of user-mode software, and allows the user to start other programs, such as a Web browser, email reader, or music player. These programs, too, make heavy use of the operating system.

> _Program antarmuka pengguna, shell atau GUI, adalah perangkat lunak mode pengguna tingkat terendah, dan memungkinkan pengguna untuk memulai program lain, seperti browser Web, pembaca email, atau pemutar musik. Program-program ini juga banyak menggunakan sistem operasi._

The placement of the operating system is shown in Fig. 1-1. It runs on the bare hardware and provides the base for all the other software.

> _Penempatan sistem operasi ditunjukkan pada Gambar. 1-1. Ini berjalan pada perangkat keras kosong dan menyediakan dasar untuk semua perangkat lunak lainnya._

An important distinction between the operating system and normal (user mode) software is that if a user does not like a particular email reader, he† is free to get a different one or write his own if he so chooses; he is not free to write his own clock interrupt handler, which is part of the operating system and is protected by hardware against attempts by users to modify it.

> _Perbedaan penting antara sistem operasi dan perangkat lunak normal (mode pengguna) adalah bahwa jika pengguna tidak menyukai pembaca email tertentu, dia bebas untuk mendapatkan yang lain atau menulis sendiri jika dia mau; dia tidak bebas untuk menulis sendiri pengendali interupsi jamnya, yang merupakan bagian dari sistem operasi dan dilindungi oleh perangkat keras dari upaya pengguna untuk memodifikasinya._

This distinction, however, is sometimes blurred in embedded systems (which may not have kernel mode) or interpreted systems (such as Java-based systems that use interpretation, not hardware, to separate the components)

> _Perbedaan ini, bagaimanapun, kadang-kadang kabur dalam sistem tertanam (yang mungkin tidak memiliki mode kernel) atau sistem yang ditafsirkan (seperti sistem berbasis Java yang menggunakan interpretasi, bukan perangkat keras, untuk memisahkan komponen)._

Also, in many systems there are programs that run in user mode but help the operating system or perform privileged functions. For example, there is often a program that allows users to change their passwords. It is not part of the operating system and does not run in kernel mode, but it clearly carries out a sensitive function and has to be protected in a special way. In some systems, this idea is carried to an extreme, and pieces of what is traditionally considered to be the operating system (such as the file system) run in user space. In such systems, it is difficult to draw a clear boundary. Everything running in kernel mode is clearly part of the operating system, but some programs running outside it are arguably also part of it, or at least closely associated with it.

> _Juga, di banyak sistem ada program yang berjalan dalam mode pengguna tetapi membantu sistem operasi atau melakukan fungsi istimewa. Misalnya, sering ada program yang memungkinkan pengguna untuk mengubah kata sandi mereka. Ini bukan bagian dari sistem operasi dan tidak berjalan dalam mode kernel, tetapi jelas menjalankan fungsi sensitif dan harus dilindungi dengan cara khusus. Dalam beberapa sistem, ide ini dibawa ke ekstrem, dan bagian dari apa yang secara tradisional dianggap sebagai operasi sistem (seperti sistem file) berjalan di ruang pengguna. Dalam sistem seperti itu, sulit untuk menarik batas yang jelas. Segala sesuatu yang berjalan dalam mode kernel jelas merupakan bagian dari sistem operasi, tetapi beberapa program yang berjalan di luarnya bisa dibilang juga merupakan bagian darinya, atau setidaknya terkait erat dengannya._

Operating systems differ from user (i.e., application) programs in ways other than where they reside. In particular, they are huge, complex, and long-lived. The source code of the heart of an operating system like Linux or Windows is on the order of fiv e million lines of code or more. To conceive of what this means, think of printing out fiv e million lines in book form, with 50 lines per page and 1000 pages per volume (larger than this book). It would take 100 volumes to list an operating system of this size—essentially an entire bookcase. Can you imagine getting a job maintaining an operating system and on the first day having your boss bring you to a bookcase with the code and say: ‘‘Go learn that.’’ And this is only for the part that runs in the kernel. When essential shared libraries are included, Windows is well over 70 million lines of code or 10 to 20 bookcases. And this excludes basic application software (things like Windows Explorer, Windows Media Player, and so on).

> _Sistem operasi berbeda dari program pengguna (yaitu, aplikasi) dengan cara selain di mana mereka berada. Secara khusus, mereka besar, kompleks, dan berumur panjang. Kode sumber jantung sistem operasi seperti Linux atau Windows berada di urutan lima juta baris kode atau lebih. Untuk memahami apa artinya ini, pikirkan untuk mencetak lima juta baris dalam bentuk buku, dengan 50 baris per halaman dan 1000 halaman per volume (lebih besar dari buku ini). Dibutuhkan 100 jilid untuk membuat daftar sistem operasi sebesar ini—pada dasarnya seluruh rak buku. Bisakah Anda bayangkan mendapatkan pekerjaan memelihara sistem operasi dan pada hari pertama bos Anda membawa Anda ke rak buku dengan kode dan berkata: ''Pergilah, pelajari itu.'' Dan ini hanya untuk bagian yang berjalan di kernel . Ketika perpustakaan bersama yang penting disertakan, Windows memiliki lebih dari 70 juta baris kode atau 10 hingga 20 rak buku. Dan ini tidak termasuk perangkat lunak aplikasi dasar (hal-hal seperti Windows Explorer, Windows Media Player, dan sebagainya)._

It should be clear now why operating systems live a long time—they are very hard to write, and having written one, the owner is loath to throw it out and start again. Instead, such systems evolve over long periods of time. Windows 95/98/Me was basically one operating system and Windows NT/2000/XP/Vista/Windows 7 is a different one. They look similar to the users because Microsoft made very sure that the user interface of Windows 2000/XP/Vista/Windows 7 was quite similar to that of the system it was replacing, mostly Windows 98. Nevertheless, there were very good reasons why Microsoft got rid of Windows 98. We will come to these when we study Windows in detail in Chap. 11.

> _Seharusnya jelas sekarang mengapa sistem operasi hidup lama—mereka sangat sulit untuk ditulis, dan setelah menulisnya, pemiliknya enggan membuangnya dan memulai lagi. Sebaliknya, sistem seperti itu berkembang dalam jangka waktu yang lama. Windows 95/98/Me pada dasarnya adalah satu sistem operasi dan Windows NT/2000/XP/Vista/Windows 7 berbeda. Mereka terlihat mirip dengan pengguna karena Microsoft memastikan bahwa antarmuka pengguna Windows 2000/XP/Vista/Windows 7 cukup mirip dengan sistem yang digantikannya, kebanyakan Windows 98. Namun demikian, ada alasan yang sangat bagus mengapa Microsoft menyingkirkan Windows 98. Kita akan sampai pada ini ketika kita mempelajari Windows secara rinci di Bab. 11._

Besides Windows, the other main example we will use throughout this book is UNIX and its variants and clones. It, too, has evolved over the years, with versions like System V, Solaris, and FreeBSD being derived from the original system whereas Linux is a fresh code base, although very closely modeled on UNIX and highly compatible with it. We will use examples from UNIX throughout this book and look at Linux in detail in Chap. 10.

> _Selain Windows, contoh utama lain yang akan kita gunakan di seluruh buku ini adalah UNIX dan variannya serta klonnya. Itu juga telah berkembang selama bertahun-tahun, dengan versi seperti System V, Solaris, dan FreeBSD yang diturunkan dari sistem aslinya, sedangkan Linux adalah basis kode baru, meskipun sangat mirip dengan model UNIX dan sangat kompatibel dengannya. Kami akan menggunakan contoh dari UNIX di seluruh buku ini dan melihat Linux secara rinci di Bab. 10._

In this chapter we will briefly touch on a number of key aspects of operating systems, including what they are, their history, what kinds are around, some of the basic concepts, and their structure. We will come back to many of these important topics in later chapters in more detail.

> _Dalam bab ini kita akan secara singkat menyentuh sejumlah aspek kunci dari sistem operasi, termasuk apa itu sistem operasi, sejarahnya, jenis apa yang ada di sekitarnya, beberapa konsep dasar, dan strukturnya. Kami akan kembali ke banyak topik penting ini di bab-bab selanjutnya secara lebih rinci._

## 1.1 APA ITU SISTEM OPERASI?

Sulit untuk menjelaskan apa itu sistem operasi selain mengatakan itu adalah perangkat lunak yang berjalan dalam mode kernel—dan bahkan itu tidak selalu benar. Bagian dari Masalahnya adalah bahwa sistem operasi melakukan dua fungsi yang pada dasarnya tidak terkait: menyediakan programmer aplikasi (dan program aplikasi, tentu saja) yang bersih kumpulan sumber daya abstrak alih-alih perangkat keras yang berantakan dan mengelolanya sumber daya perangkat keras. Bergantung pada siapa yang berbicara, Anda mungkin mendengar sebagian besar tentang satu fungsi atau yang lain. Sekarang mari kita lihat keduanya.

### 1.1.1 Sistem Operasi sebagai Mesin yang Diperpanjang

Arsitektur (set instruksi, organisasi memori, I/O, dan struktur bus) dari kebanyakan komputer pada tingkat bahasa mesin adalah primitif dan canggung untuk program, terutama untuk input/output. Untuk membuat poin ini lebih konkret, pertimbangkan hard disk SATA (Serial ATA) modern yang digunakan di sebagian besar komputer. Sebuah buku (Ander son, 2007) menjelaskan versi awal dari antarmuka ke disk—apa yang harus diketahui oleh seorang programmer untuk menggunakan disk—berisi lebih dari 450 halaman. Sejak itu, antarmuka telah direvisi beberapa kali dan lebih rumit daripada sebelumnya 2007. Jelas, tidak ada programmer waras yang mau berurusan dengan disk ini di tingkat perangkat keras. Sebagai gantinya, perangkat lunak, yang disebut driver disk, menangani perangkat keras dan menyediakan antarmuka untuk membaca dan menulis blok disk, tanpa masuk ke Rinciannya. Sistem operasi berisi banyak driver untuk mengontrol perangkat I/O. 

Tetapi bahkan level ini terlalu rendah untuk sebagian besar aplikasi. Untuk alasan ini, semua sistem operasi menyediakan lapisan abstraksi lain untuk menggunakan disk: file. Dengan menggunakan abstraksi ini, program dapat membuat, menulis, dan membaca file, tanpa harus berurusan dengan rincian berantakan tentang bagaimana perangkat keras benar-benar bekerja. 

Abstraksi ini adalah kunci untuk mengelola semua kerumitan ini. Abstraksi yang bagus mengubah tugas yang hampir mustahil menjadi dua tugas yang dapat dikelola. Yang pertama adalah mendefinisikan dan mengimplementasikan abstraksi. Yang kedua adalah menggunakan abstraksi ini untuk menyelesaikan masalah di tangan. Salah satu abstraksi yang dipahami oleh hampir setiap pengguna komputer adalah file, seperti yang disebutkan di atas. Ini adalah informasi yang berguna, seperti digital foto, pesan email yang disimpan, lagu, atau halaman Web. Jauh lebih mudah untuk menangani foto, email, lagu, dan halaman Web daripada dengan detail disk SATA (atau lainnya). Tugas sistem operasi adalah membuat abstraksi yang baik dan kemudian mengimplementasikannya dan mengelola objek abstrak yang dibuat. Dalam buku ini, kita akan berbicara banyak tentang abstraksi. Mereka adalah salah satu kunci untuk memahami sistem operasi.

Poin ini sangat penting sehingga perlu diulang dengan kata-kata yang berbeda. Dengan semua hormat kepada para insinyur industri yang merancang Macintosh dengan sangat hati-hati, perangkat kerasnya jelek. Prosesor nyata, memori, disk, dan perangkat lain sangat rumit dan menghadirkan antarmuka yang sulit, canggung, istimewa, dan tidak konsisten kepada orang-orang yang harus menulis perangkat lunak untuk menggunakannya. Terkadang ini karena dengan kebutuhan untuk kompatibilitas dengan perangkat keras yang lebih tua. Di lain waktu itu adalah usaha untuk menghemat uang. Namun, seringkali, perancang perangkat keras tidak menyadari (atau peduli) berapa banyak masalah yang mereka sebabkan untuk perangkat lunak. Salah satu tugas utama dari sistem operasi adalah menyembunyikan perangkat keras dan menyajikan program (dan programmer) dengan abstraksi yang bagus, bersih, elegan, konsisten, sebagai gantinya. Sistem operasi mengubah yang jelek menjadi indah, seperti yang ditunjukkan pada Gambar. 1-2

<img src="/Gambar1-2.JPG" width="90%" height="90%">

Gambar 1-2. Sistem operasi mengubah perangkat keras yang jelek menjadi abstraksi yang indah.

Perlu dicatat bahwa pelanggan nyata sistem operasi adalah program aplikasi (melalui pemrogram aplikasi, tentu saja). Mereka adalah orang-orangnya yang berhubungan langsung dengan sistem operasi dan abstraksinya. Sebaliknya, akhir pengguna berurusan dengan abstraksi yang disediakan oleh antarmuka pengguna, baik shell baris perintah atau antarmuka grafis. Sementara abstraksi di antarmuka pengguna mungkin mirip dengan yang disediakan oleh sistem operasi, ini tidak selalu kasus. Untuk memperjelas poin ini, pertimbangkan desktop Windows normal dan prompt perintah berorientasi baris. Keduanya adalah program yang berjalan pada sistem operasi Windows dan menggunakan abstraksi yang disediakan Windows, tetapi keduanya menawarkan antarmuka pengguna yang sangat berbeda. Demikian pula, pengguna Linux yang menjalankan Gnome atau KDE melihat antarmuka yang berbeda dari pengguna Linux yang bekerja langsung di atas X yang mendasarinya Sistem Jendela, tetapi abstraksi sistem operasi yang mendasarinya sama dalam kedua kasus.

Dalam buku ini, kita akan mempelajari abstraksi yang disediakan untuk program aplikasi di
sangat detail, tetapi tidak banyak bicara tentang antarmuka pengguna. Itu besar dan penting
subjek, tetapi hanya satu yang terkait dengan sistem operasi.

### 1.1.2 Sistem Operasi sebagai Resource Manager

Konsep sistem operasi yang terutama menyediakan abstraksi untuk program aplikasi adalah tampilan top-down. Pandangan alternatif, dari bawah ke atas, menyatakan bahwa sistem operasi ada untuk mengelola semua bagian dari sistem yang kompleks. Komputer modern terdiri dari prosesor, memori, timer, disk, mouse, antarmuka jaringan, printer, dan berbagai perangkat lainnya. Dalam tampilan bottom-up, pekerjaan sistem operasi adalah untuk menyediakan alokasi yang teratur dan terkendali dari prosesor, memori, dan perangkat I/O di antara berbagai program yang menginginkannya.

Sistem operasi modern memungkinkan beberapa program berada di memori dan dijalankan pada saat yang sama. Bayangkan apa yang akan terjadi jika tiga program berjalan pada beberapa komputer semua mencoba untuk mencetak output mereka secara bersamaan pada printer yang sama. Pertama beberapa baris cetakan mungkin berasal dari program 1, beberapa baris berikutnya dari program 2, lalu beberapa dari program 3, dan sebagainya. Hasilnya akan menjadi kekacauan total. Pengoperasian sistem dapat menertibkan potensi kekacauan dengan menyangga semua output yang ditentukan untuk printer pada disk. Ketika satu program selesai, sistem operasi dapat kemudian salin outputnya dari file disk tempat disimpan untuk printer, sementara pada saat yang sama program lain dapat terus menghasilkan lebih banyak output, tidak menyadari fakta bahwa output tidak benar-benar masuk ke printer (belum).

Ketika komputer (atau jaringan) memiliki lebih dari satu pengguna, kebutuhan untuk mengelola dan melindungi memori, perangkat I/O, dan sumber daya lainnya bahkan lebih sejak pengguna dapat mengganggu satu sama lain. Selain itu, pengguna sering kali perlu berbagi tidak hanya perangkat keras, tetapi juga informasi (file, database, dll.) Pendeknya, pandangan sistem operasi ini menyatakan bahwa tugas utamanya adalah untuk melacak program mana yang menggunakan sumber daya mana, untuk mengabulkan permintaan sumber daya, untuk memperhitungkan untuk penggunaan, dan untuk menengahi permintaan yang bertentangan dari program dan pengguna yang berbeda.

Manajemen sumber daya mencakup multiplexing (berbagi) sumber daya dalam dua cara yang berbeda: dalam waktu dan dalam ruang. Ketika sumber daya digandakan waktu, berbeda program atau pengguna bergiliran menggunakannya. Pertama, salah satu dari mereka dapat menggunakan sumber daya, lalu yang lain, dan seterusnya. Misalnya, dengan hanya satu CPU dan beberapa program yang ingin dijalankan di atasnya, sistem operasi terlebih dahulu mengalokasikan CPU ke satu program, kemudian, setelah berjalan cukup lama, program lain akan menggunakan CPU, kemudian yang lain, dan akhirnya yang pertama lagi. Menentukan bagaimana sumber daya adalah waktu multiplexing—siapa yang maju berikutnya dan untuk berapa lama—adalah tugas sistem operasi. Contoh lain dari multiplexing waktu adalah berbagi printer. Ketika banyak pekerjaan cetak diantrekan untuk dicetak pada satu printer, keputusan harus dibuat tentang mana yang akan dicetak berikutnya.

Jenis multiplexing lainnya adalah space multiplexing. Alih-alih pelanggan bergiliran, masing-masing mendapat bagian dari sumber daya. Sebagai contoh, memori utama biasanya tidak dibagi di antara beberapa program yang sedang berjalan, sehingga masing-masing dapat menjadi residen di waktu yang sama (misalnya, untuk bergiliran menggunakan CPU). Dengan asumsi ada cukup memori untuk menampung banyak program, lebih efisien untuk menampung beberapa program dalam memori sekaligus daripada memberikan salah satu dari mereka semua, terutama jika itu hanya membutuhkan sebagian kecil dari total. Tentu saja hal ini menimbulkan masalah keadilan, perlindungan, dan sebagainya, dan terserah pada sistem operasi untuk menyelesaikannya. Lain sumber daya yang di-multipleks ruang adalah disk. Dalam banyak sistem, satu disk dapat menyimpan file dari banyak pengguna secara bersamaan. Mengalokasikan ruang disk dan menyimpannya melacak siapa yang menggunakan blok disk mana yang merupakan tugas khas sistem operasi.

## 1.2 SEJARAH SISTEM OPERASI

Sistem operasi telah berkembang selama bertahun-tahun. Pada bagian berikut kita akan melihat secara singkat beberapa hal yang menjadi sorotan. Karena sistem operasi memiliki secara historis terkait erat dengan arsitektur komputer tempat mereka dijalankan, kita akan melihat generasi komputer yang berurutan untuk melihat seperti apa sistem operasinya. Pemetaan generasi sistem operasi ini ke komputer generasi itu kasar, tetapi itu memberikan beberapa struktur di mana tidak ada yang bijaksana.

Perkembangan yang diberikan di bawah ini sebagian besar kronologis, tetapi telah bergelombang mengendarai. Setiap pengembangan tidak menunggu sampai yang sebelumnya selesai dengan baik sebelumnya mulai. Ada banyak tumpang tindih, belum lagi banyak awal yang salah dan jalan buntu. Ambil ini sebagai panduan, bukan sebagai kata terakhir.

Komputer digital pertama yang benar dirancang oleh ahli matematika Inggris Charles Babbage (1792–1871). Meskipun Babbage menghabiskan sebagian besar hidupnya dan mencari lagu untuk mencoba membangun ''mesin analitiknya,'' dia tidak pernah membuatnya bekerja dengan baik karena itu murni mekanis, dan teknologi pada zamannya tidak dapat menghasilkan roda, roda gigi, dan roda gigi yang dibutuhkan dengan presisi tinggi yang dia butuhkan. Tidak perlu untuk mengatakan, mesin analitik tidak memiliki sistem operasi. Sebagai tambahan sejarah yang menarik, Babbage menyadari bahwa dia akan membutuhkan perangkat lunak untuk mesin analitiknya, jadi dia mempekerjakan seorang wanita muda bernama Ada Lovelace, yang merupakan putri penyair Inggris terkenal Lord Byron, sebagai yang pertama di dunia programmer. Bahasa pemrograman Ada® dinamai menurut namanya.

### 1.2.1 Generasi Pertama (1945–55): Tabung Vakum

Setelah upaya Babbage yang gagal, hanya sedikit kemajuan yang dibuat dalam konstruksi komputer digital hingga periode Perang Dunia II, yang memicu ledakan aktivitas. Profesor John Atanasoff dan mahasiswa pascasarjananya Clifford Berry membangun apa yang sekarang dianggap sebagai komputer digital pertama yang berfungsi di Iowa State University. Ini digunakan 300 tabung vakum. Pada waktu yang hampir bersamaan, Konrad Zuse di Berlin membangun komputer Z3 dari relai elektromekanis. Pada tahun 1944, Colossus adalah dibangun dan diprogram oleh sekelompok ilmuwan (termasuk Alan Turing) di Bletchley Park, Inggris, Mark I dibangun oleh Howard Aiken di Harvard, dan ENIAC dibangun oleh William Mauchley dan mahasiswa pascasarjananya J. Presper Eckert di Uiversitas Pennsylvania. Beberapa biner, beberapa menggunakan tabung vakum, beberapa dapat diprogram, tetapi semuanya sangat primitif dan membutuhkan waktu beberapa detik untuk tampil merata perhitungan paling sederhana.

Pada hari-hari awal ini, sekelompok orang (biasanya insinyur) merancang, dibangun, diprogram, dioperasikan, dan dipelihara setiap mesin. Semua pemrograman adalah dilakukan dalam bahasa mesin mutlak, atau bahkan lebih buruk lagi, dengan memasang kabel sirkuit listrik dengan menghubungkan ribuan kabel ke plugboard untuk mengontrol mesin fungsi dasar. Bahasa pemrograman tidak diketahui (bahkan bahasa assembly tidak diketahui). Sistem operasi tidak pernah terdengar sebelumnya. Mode operasi biasa adalah untuk programmer untuk mendaftar untuk blok waktu menggunakan lembar pendaftaran di dinding, lalu turun ke ruang mesin, masukkan plugboard-nya ke dalam komputer, dan menghabiskan beberapa jam berikutnya berharap tidak ada 20.000 atau lebih tabung vakum yang terbakar selama pengoperasian. Hampir semua masalah itu sederhana perhitungan matematis dan numerik langsung, seperti penggilingan tabel sinus, cosinus, dan logaritma, atau menghitung lintasan artileri.

Pada awal 1950-an, rutinitas sedikit membaik dengan diperkenalkannya dari kartu berlubang. Sekarang mungkin untuk menulis program pada kartu dan membacanya di alih-alih menggunakan plugboard; jika tidak, prosedurnya sama.

### 1.2.2 Generasi Kedua (1955–65): Transistor dan Sistem Batch

Pengenalan transistor pada pertengahan 1950-an mengubah gambaran secara radikal. Komputer menjadi cukup andal sehingga dapat diproduksi dan dijual untuk membayar pelanggan dengan harapan bahwa mereka akan terus berfungsi lama cukup untuk menyelesaikan pekerjaan yang bermanfaat. Untuk pertama kalinya, ada pemisahan yang jelas antara desainer, pembangun, operator, pemrogram, dan pemeliharaan per sonnel.

Mesin-mesin ini, sekarang disebut mainframe, dikunci dalam jumlah besar, khususnya ruang komputer ber-AC, dengan staf operator profesional untuk menjalankannya. Hanya perusahaan besar atau lembaga pemerintah atau universitas besar yang mampu label harga jutaan dolar. Untuk menjalankan pekerjaan (yaitu, program atau serangkaian program), seorang programmer pertama-tama akan menulis program di atas kertas (dalam FORTRAN atau assem bler), kemudian memencetnya di kartu. Dia kemudian akan membawa dek kartu ke input kamar dan serahkan ke salah satu operator dan pergi minum kopi sampai outputnya siap.

Ketika komputer menyelesaikan pekerjaan apa pun yang sedang dijalankannya, seorang operator akan pergi ke printer dan merobek output dan membawanya ke output ruangan, sehingga programmer bisa mengumpulkannya nanti. Kemudian dia akan mengambil salah satu dari deck kartu yang telah dibawa dari ruang input dan membacanya. Jika kompiler FOR TRAN diperlukan, operator harus mendapatkannya dari lemari arsip dan membacanya. Banyak waktu komputer terbuang saat operator berjalan di sekitar ruang mesin.

Mengingat tingginya biaya peralatan, tidak mengherankan bahwa orang-orang dengan cepat mencari cara untuk mengurangi waktu yang terbuang. Solusi yang umumnya diadopsi adalah sistem batch. Ide di baliknya adalah untuk mengumpulkan baki yang penuh dengan pekerjaan di input ruangan dan kemudian membacanya ke pita magnetik menggunakan komputer kecil (relatif) murah, seperti IBM 1401, yang cukup baik dalam membaca kartu, menyalin kaset, dan mencetak hasil, tetapi sama sekali tidak pandai dalam perhitungan numerik.

Mesin lain yang jauh lebih mahal, seperti IBM 7094, digunakan untuk komputasi nyata. Situasi ini ditunjukkan pada Gambar. 1-3. Setelah sekitar satu jam mengumpulkan sejumlah pekerjaan, kartu-kartu itu dibacakan ke pita magnetik, yang dibawa ke ruang mesin, di mana ia dipasang sebuah kaset. Operator kemudian memuat program khusus (nenek moyang hari ini sistem operasi), yang membaca pekerjaan pertama dari tape dan menjalankannya. Outputnya adalah ditulis ke kaset kedua, bukannya dicetak. Setelah setiap pekerjaan selesai, sistem operasi secara otomatis membaca pekerjaan berikutnya dari rekaman itu dan mulai berjalan.

![image](https://user-images.githubusercontent.com/112523858/189243986-cd644aab-b3dd-410b-bd3b-c178a906d215.png)

Gambar 1-3. Sistem batch awal. (a) Pemrogram membawa kartu ke 1401. (b) 1401 membaca batch pekerjaan ke tape. (c) Operator membawa pita input ke 7094. (d) 7094 melakukan komputasi. (e) Operator membawa pita keluaran ke 1401. (f) 1401 cetakan keluaran dia. 

Ketika seluruh batch selesai, operator menghapus input dan output kaset, mengganti pita input dengan batch berikutnya, dan membawa pita keluaran ke a 1401 untuk mencetak off line (yaitu, tidak terhubung ke komputer utama).

![image](https://user-images.githubusercontent.com/112523858/189244740-7fe92d65-74aa-4ac0-a3a2-6f5ac248382e.png)

Struktur pekerjaan input tipikal ditunjukkan pada Gambar. 1-4. Ini dimulai dengan kartu $JOB, menentukan waktu berjalan maksimum dalam menit, nomor akun yang akan dibebankan, dan nama programmer. Kemudian datang kartu $FORTRAN, memberi tahu sistem operasi untuk memuat compiler FORTRAN dari sistem tape. Itu langsung diikuti oleh program yang akan dikompilasi, dan kemudian kartu $LOAD, mengarahkan sistem operasi untuk memuat program objek yang baru saja dikompilasi. (Pro gram yang dikompilasi sering ditulis pada kaset awal dan harus dimuat secara eksplisit.) Selanjutnya datang kartu $RUN, memberi tahu sistem operasi untuk menjalankan program dengan data mengikutinya. Akhirnya, kartu $END menandai akhir dari pekerjaan. Primitif ini kartu kontrol adalah cikal bakal shell modern dan penerjemah baris perintah.

Komputer generasi kedua yang besar sebagian besar digunakan untuk perhitungan ilmiah dan teknik, seperti memecahkan persamaan diferensial parsial yang sering terjadi dalam fisika dan teknik. Mereka sebagian besar diprogram dalam FORTRAN dan bahasa campuran. Sistem operasi yang umum adalah FMS (Fortran Monitor System) dan IBSYS, sistem operasi IBM untuk 7094.

### 1.2.3 Generasi Ketiga (1965–1980): IC dan Multiprogramming

Pada awal 1960-an, sebagian besar produsen komputer memiliki dua lini produk yang berbeda dan tidak kompatibel. Di satu sisi, ada komputer ilmiah skala besar yang berorientasi pada kata, seperti 7094, yang digunakan untuk perhitungan numerik kekuatan industri dalam sains dan teknik. Di sisi lain, ada Gambar 1-4. Struktur pekerjaan FMS yang khas. berorientasi karakter, komputer komersial, seperti 1401, yang secara luas digunakan untuk penyortiran dan pencetakan pita oleh bank dan perusahaan asuransi.

Mengembangkan dan memelihara dua lini produk yang sama sekali berbeda merupakan proposisi yang mahal bagi produsen. Selain itu, banyak pelanggan komputer baru pada awalnya membutuhkan mesin kecil tetapi kemudian menjadi lebih besar dan menginginkan yang lebih besar mesin yang akan menjalankan semua program lama mereka, tetapi lebih cepat.

IBM berusaha untuk memecahkan kedua masalah ini dengan satu langkah dengan memperkenalkan System/360. 360 adalah serangkaian mesin yang kompatibel dengan perangkat lunak mulai dari model berukuran 1401 hingga yang jauh lebih besar, lebih kuat daripada yang perkasa. 7094. Mesin hanya berbeda dalam harga dan kinerja (memori maksimum, kecepatan prosesor, jumlah perangkat I/O yang diizinkan, dan sebagainya). Karena mereka semua memiliki arsitektur dan set instruksi yang sama, program yang ditulis untuk satu mesin dapat menjalankan semua yang lain-setidaknya dalam teori. (Tapi seperti yang dikatakan Yogi Berra: ''In teori, teori dan praktek adalah sama; dalam praktiknya, mereka tidak.'') Sejak 360 dirancang untuk menangani komputasi ilmiah (yaitu, numerik) dan komersial, satu keluarga mesin dapat memenuhi kebutuhan semua pelanggan. Selanjutnya tahun, IBM keluar dengan penerus kompatibel ke garis 360, menggunakan teknologi yang lebih modern, yang dikenal sebagai 370, 4300, 3080, dan 3090. Seri z keturunan terbaru dari garis ini, meskipun telah menyimpang jauh dari asli.

IBM 360 adalah lini komputer besar pertama yang menggunakan IC (skala kecil) (Inte grated Circuits), sehingga memberikan keunggulan harga/kinerja utama dibandingkan mesin generasi kedua, yang dibangun dari transistor individu.

TIDAK sukses langsung, dan ide dari keluarga komputer yang kompatibel adalah segera diadopsi oleh semua produsen besar lainnya. Keturunan dari mesin ini masih digunakan di pusat komputer sampai sekarang. Sekarang ini sering digunakan untuk mengelola database besar (misalnya, untuk sistem reservasi maskapai penerbangan) atau sebagai server untuk Situs World Wide Web yang harus memproses ribuan permintaan per detik.

Kekuatan terbesar dari ide '' keluarga tunggal '' secara bersamaan adalah kelemahan terbesarnya. Niat awalnya adalah bahwa semua perangkat lunak, termasuk operasi sistem, OS/360, harus bekerja pada semua model. Itu harus berjalan pada sistem kecil, yang sering kali hanya mengganti 1401 untuk menyalin kartu ke tape, dan pada sistem yang sangat besar, yang sering menggantikan 7094 untuk melakukan prakiraan cuaca dan komputasi berat lainnya. Itu harus bagus pada sistem dengan sedikit periferal dan pada sistem dengan banyak periferal. Itu harus bekerja di lingkungan komersial dan di lingkungan ilmiah. Di atas segalanya, itu harus efisien untuk semua kegunaan yang berbeda ini.

Tidak mungkin IBM (atau siapa pun dalam hal ini) dapat menulis bagian dari perangkat lunak untuk memenuhi semua persyaratan yang saling bertentangan. Hasilnya adalah sistem operasi yang sangat besar dan luar biasa kompleks, mungkin dua hingga tiga urutan besarnya lebih besar dari FMS. Itu terdiri dari jutaan jalur perakitan bahasa yang ditulis oleh ribuan programmer, dan berisi ribuan ribuan bug, yang memerlukan aliran rilis baru secara terus-menerus dalam mencoba untuk memperbaikinya. Setiap rilis baru memperbaiki beberapa bug dan memperkenalkan yang baru yang, sehingga jumlah bug mungkin tetap konstan dari waktu ke waktu.

Salah satu desainer OS/360, Fred Brooks, kemudian menulis sebuah jenaka dan buku tajam (Brooks, 1995) menggambarkan pengalamannya dengan OS/360. Sementara itu tidak mungkin untuk meringkas buku di sini, cukup untuk mengatakan bahwa sampulnya menunjukkan kawanan binatang prasejarah terjebak di lubang tar. Sampul Silberschatz dkk. (2012) membuat poin serupa tentang sistem operasi yang menjadi dinosaurus.

Terlepas dari ukuran dan masalahnya yang sangat besar, OS/360 dan sistem operasi generasi ketiga serupa yang diproduksi oleh produsen komputer lain benar-benar memuaskan sebagian besar pelanggan mereka dengan cukup baik. Mereka juga mempopulerkan beberapa kunci teknik yang tidak ada dalam sistem operasi generasi kedua. Mungkin yang paling penting adalah multiprogramming. Pada 7094, saat pekerjaan saat ini dijeda untuk menunggu rekaman atau operasi I/O lainnya selesai, CPU hanya duduk idle sampai I/O selesai. Dengan perhitungan ilmiah yang sangat terikat CPU, I/O adalah jarang, jadi waktu yang terbuang ini tidak signifikan. Dengan pemrosesan data komersial, waktu tunggu I/O seringkali bisa mencapai 80 atau 90% dari total waktu, jadi harus ada sesuatu dilakukan untuk menghindari CPU (mahal) menganggur begitu banyak.

Solusi yang berkembang adalah dengan mempartisi memori menjadi beberapa bagian, dengan pekerjaan yang berbeda di setiap partisi, seperti yang ditunjukkan pada Gambar. 1-5. Sementara satu pekerjaan sedang menunggu I/O selesai, pekerjaan lain bisa menggunakan CPU. Jika cukup banyak pekerjaan dapat diadakan di memori utama sekaligus, CPU dapat tetap sibuk hampir 100% sepanjang waktu.

Memiliki banyak pekerjaan dengan aman di memori sekaligus membutuhkan perangkat keras khusus untuk melindungi setiap pekerjaan melawan pengintaian dan kerusakan oleh yang lain, tetapi 360 dan lainnya sistem generasi ketiga dilengkapi dengan perangkat keras ini.

![image](https://user-images.githubusercontent.com/112523858/189245081-14a551c9-3532-4cf6-b19d-ae7c367eb3ed.png)

Gambar 1-5. Sebuah sistem multiprogramming dengan tiga pekerjaan di memori.

Fitur utama lain yang ada dalam sistem operasi generasi ketiga adalah kemampuan untuk membaca pekerjaan dari kartu ke disk segera setelah dibawa ke ruang komputer. Kemudian, setiap kali pekerjaan yang sedang berjalan selesai, sistem operasi dapat memuat pekerjaan baru dari disk ke partisi yang sekarang kosong dan menjalankannya. Teknik ini disebut spooling (dari Simultaneous Peripheral Operation On Line) dan juga digunakan untuk keluaran. Dengan spooling, 1401 tidak lagi diperlukan, dan banyak membawa kaset menghilang.

Meskipun sistem operasi generasi ketiga sangat cocok untuk ilmiah besar perhitungan dan pemrosesan data komersial besar-besaran, pada dasarnya mereka masih sistem batch. Banyak programmer merindukan hari-hari generasi pertama ketika mereka memiliki mesin untuk diri mereka sendiri selama beberapa jam, sehingga mereka dapat men-debug pro gram mereka dengan cepat. Dengan sistem generasi ketiga, waktu antara mengirimkan pekerjaan dan mendapatkan kembali hasilnya seringkali beberapa jam, jadi satu koma salah tempat dapat menyebabkan kompilasi gagal, dan pemrogram membuang waktu setengah hari. Pro grammer tidak begitu menyukainya.

Keinginan untuk waktu respons yang cepat ini membuka jalan bagi pembagian waktu, sebuah varian multiprogramming, di mana setiap pengguna memiliki terminal online. Dalam pembagian waktu sistem, jika 20 pengguna masuk dan 17 dari mereka berpikir atau berbicara atau minum kopi, CPU dapat dialokasikan secara bergantian ke tiga pekerjaan yang menginginkan layanan. Sejak orang yang men-debug program biasanya mengeluarkan perintah pendek (misalnya, mengkompilasi prosedur lima halaman†) daripada yang panjang (misalnya, mengurutkan satu juta file rekaman), komputer dapat menyediakan layanan yang cepat dan interaktif ke sejumlah pengguna dan mungkin juga mengerjakan pekerjaan batch besar di latar belakang saat CPU tidak digunakan. Itu sistem timesharing tujuan umum pertama, CTSS (Compatible Time Sharing System), dikembangkan di M.I.T. pada 7094 yang dimodifikasi secara khusus (Corbato´ et al., 1962).

Namun, pembagian waktu tidak benar-benar menjadi populer sampai perlindungan yang diperlukan perangkat keras menjadi luas selama generasi ketiga. Setelah keberhasilan sistem CTSS, M.I.T., Bell Labs, dan General Electric (pada saat itu produsen komputer besar) memutuskan untuk memulai pengembangan "utilitas komputer", yaitu, mesin yang akan mendukung beberapa ratus pengguna timesharing simultan. Model mereka adalah sistem kelistrikan—ketika Anda membutuhkan tenaga listrik, Anda cukup memasang steker di dinding, dan dengan alasan, sebagai banyak kekuatan yang Anda butuhkan akan ada di sana. Perancang sistem ini, yang dikenal sebagai MULTICS (Layanan Informasi dan Komputasi MULTIplexed), dibayangkan satu mesin besar yang menyediakan daya komputasi untuk semua orang di wilayah Boston. 

Gagasan bahwa mesin 10.000 kali lebih cepat daripada mainframe GE-645 mereka adalah dijual (dengan harga di bawah $ 1000) oleh jutaan hanya 40 tahun kemudian adalah sains murni fiksi. Semacam ide kereta bawah laut supersonik trans-Atlantik sekarang.

MULTICS adalah sukses campuran. Itu dirancang untuk mendukung ratusan pengguna pada mesin hanya sedikit lebih kuat daripada PC berbasis Intel 386, meskipun memiliki lebih banyak kapasitas I/O. Ini tidak terlalu gila kedengarannya, karena di dalamnya hari orang tahu bagaimana menulis kecil, program efisien, keterampilan yang kemudian benar-benar hilang. Ada banyak alasan mengapa MULTICS tidak mengambil alih dunia, tidak sedikit yang ditulis dalam bahasa pemrograman PL/I, dan kompiler PL/I terlambat bertahun-tahun dan hampir tidak berfungsi sama sekali ketika akhirnya tiba. Selain itu, MULTICS sangat ambisius untuk waktu, seperti mesin analitik Charles Babbage di abad kesembilan belas. Untuk mempersingkat cerita, MULTICS memperkenalkan banyak ide mani ke dalam literatur komputer, tetapi mengubahnya menjadi produk yang serius dan komersial utama kesuksesan jauh lebih sulit daripada yang diperkirakan siapa pun. Bell Labs keluar dari proyek, dan General Electric keluar dari bisnis komputer sama sekali. Namun, M.I.T. bertahan dan akhirnya membuat MULTICS bekerja. Itu akhirnya dijual sebagai produk komersial oleh perusahaan (Honeywell) yang membeli bisnis komputer GE dan dipasang oleh sekitar 80 perusahaan besar dan universitas di seluruh dunia.

Meskipun jumlahnya sedikit, pengguna MULTICS sangat setia. Umum Motors, Ford, dan Badan Keamanan Nasional AS, misalnya, menutup Sistem MULTICS hanya di akhir 1990-an, 30 tahun setelah MULTICS dirilis, setelah bertahun-tahun mencoba membuat Honeywell memperbarui perangkat kerasnya.

Pada akhir abad ke-20, konsep utilitas komputer telah gagal keluar, tetapi mungkin kembali dalam bentuk komputasi awan, di mana komputer yang relatif kecil (termasuk smartphone, tablet, dan sejenisnya) terhubung ke server di pusat data yang luas dan jauh di mana semua komputasi dilakukan , dengan komputer lokal hanya menangani antarmuka pengguna. Motivasi disini adalah bahwa kebanyakan orang tidak ingin administrasi yang semakin kompleks dan rewel sistem komputer dan lebih suka pekerjaan itu dilakukan oleh tim profesional, misalnya, orang yang bekerja untuk perusahaan yang menjalankan pusat data. Merce e-com sudah berkembang ke arah ini, dengan berbagai perusahaan menjalankan email pada server multiprosesor yang terhubung dengan mesin klien sederhana, sangat banyak semangat desain MULTICS.

Meskipun kurang sukses secara komersial, MULTICS memiliki pengaruh besar pada sistem operasi berikutnya (terutama UNIX dan turunannya, FreeBSD, Linux, iOS, dan Android). Hal ini dijelaskan dalam beberapa makalah dan buku (Corbato´ et al., 1972; Corbato´ dan Vyssotsky, 1965; Daley dan Dennis, 1968; Organik, 1972; dan Saltzer, 1974). Ia juga memiliki Situs Web aktif, yang terletak di www.multicians.org, dengan banyak informasi tentang sistem, perancangnya, dan penggunanya. Perkembangan besar lainnya selama generasi ketiga adalah fenomenal pertumbuhan komputer mini, dimulai dengan DEC PDP-1 pada tahun 1961. PDP-1 memiliki hanya 4K kata 18-bit, tetapi pada $ 120.000 per mesin (kurang dari 5% dari harga 7094), itu dijual seperti kacang goreng. Untuk jenis pekerjaan nonnumerik tertentu, itu hampir secepat tahun 7094 dan melahirkan industri yang sama sekali baru. Itu dengan cepat diikuti oleh serangkaian PDP lain (tidak seperti keluarga IBM, semuanya tidak kompatibel) yang berpuncak pada PDP-11.

Salah satu ilmuwan komputer di Bell Labs yang pernah mengerjakan MULTICS proyek, Ken Thompson, kemudian menemukan komputer mini PDP-7 kecil yang tidak salah satunya menggunakan dan mulai menulis MULTICS versi satu pengguna yang dilucuti.

Karya ini kemudian berkembang menjadi sistem operasi UNIX, yang menjadi populer di dunia akademik, dengan instansi pemerintah, dan dengan banyak perusahaan. Sejarah UNIX telah diceritakan di tempat lain (misalnya, Salus, 1994). Bagian dari itu cerita akan diberikan di Bab. 10. Untuk saat ini, cukup dikatakan demikian karena sumbernya kode tersedia secara luas, berbagai organisasi mengembangkan versi mereka sendiri (tidak kompatibel), yang menyebabkan kekacauan. Dua versi utama dikembangkan, Sistem V, dari AT&T, dan BSD (Distribusi Perangkat Lunak Berkeley) dari University of Cali fornia di Berkeley. Ini memiliki varian kecil juga. Untuk memungkinkan menulis program yang dapat berjalan pada sistem UNIX apa pun, IEEE mengembangkan standar untuk UNIX, disebut POSIX, yang sekarang didukung oleh sebagian besar versi UNIX. POSIX mendefinisikan antarmuka panggilan sistem minimal yang harus didukung oleh sistem UNIX yang sesuai. Di faktanya, beberapa sistem operasi lain sekarang juga mendukung antarmuka POSIX.

Sebagai tambahan, perlu disebutkan bahwa pada tahun 1987, penulis merilis sedikit tiruan dari UNIX, yang disebut MINIX, untuk tujuan pendidikan. Secara fungsional, MINIX adalah sangat mirip dengan UNIX, termasuk dukungan POSIX. Sejak saat itu, versi aslinya telah berkembang menjadi MINIX 3, yang sangat modular dan berfokus pada sangat tinggi keandalan. Ia memiliki kemampuan untuk mendeteksi dan mengganti modul yang rusak atau bahkan macet (seperti driver perangkat I/O) dengan cepat tanpa reboot dan tanpa mengganggu program yang sedang berjalan. Fokusnya adalah menyediakan ketergantungan dan ketersediaan yang sangat tinggi.

Sebuah buku yang menjelaskan operasi internal dan daftar kode sumber dalam lampiran juga tersedia (Tanenbaum dan Woodhull, 2006). Sistem MINIX 3 tersedia secara gratis (termasuk semua kode sumber) melalui Internet di www.minix3.org.

Keinginan untuk produksi gratis (sebagai lawan dari pendidikan) versi MINIX memimpin seorang mahasiswa Finlandia, Linus Torvalds, untuk menulis Linux. Sistem ini secara langsung terinspirasi oleh dan dikembangkan pada MINIX dan awalnya mendukung berbagai fitur MINIX (mis., Sistem file MINIX). Sejak itu telah diperpanjang dalam banyak cara oleh banyak orang tetapi masih mempertahankan beberapa struktur dasar yang umum untuk MINIX dan untuk UNIX. Pembaca yang tertarik dengan sejarah rinci Linux dan open source gerakan mungkin ingin membaca buku Glyn Moody (2001). Sebagian besar dari apa yang akan terjadi dikatakan tentang UNIX dalam buku ini dengan demikian berlaku untuk Sistem V, MINIX, Linux, dan lainnya versi dan klon UNIX juga 

### 1.2.4 Generasi Keempat (1980–Sekarang): Komputer Pribadi

Dengan berkembangnya sirkuit LSI (Large Scale Integration)—chip yang berisi ribuan transistor pada satu sentimeter persegi silikon—usia komputer pribadi muncul. Dalam hal arsitektur, komputer pribadi (awalnya disebut mikrokomputer) tidak jauh berbeda dari komputer mini Kelas PDP-11, tapi dari segi harga tentu berbeda. Dimana komputer mini memungkinkan departemen di perusahaan atau universitas untuk memiliki komputernya sendiri, chip mikroprosesor memungkinkan untuk satu individu memiliki komputer pribadinya sendiri.

Pada tahun 1974, ketika Intel keluar dengan 8080, tujuan umum pertama 8-bit CPU, ia menginginkan sistem operasi untuk 8080, sebagian untuk dapat mengujinya. Intel meminta salah satu konsultannya, Gary Kildall, untuk menulis satu. Kildall dan seorang teman dulu membuat pengontrol untuk floppy disk 8 inci Shugart Associates yang baru dirilis dan menghubungkan floppy disk hingga 8080, sehingga menghasilkan komputer mikro pertama dengan sebuah disk. Kildall kemudian menulis sistem operasi berbasis disk yang disebut CP/M (Kontrol Program untuk Mikrokomputer) untuk itu. Karena Intel tidak berpikir bahwa berbasis disk mikrokomputer memiliki banyak masa depan, ketika Kildall meminta hak atas CP/M, Intel mengabulkan permintaannya. Kildall kemudian membentuk sebuah perusahaan, Digital Research, untuk lebih mengembangkan dan menjual CP/M.

Pada tahun 1977, Digital Research menulis ulang CP/M agar cocok untuk dijalankan di banyak mikrokomputer yang menggunakan 8080, Zilog Z80, dan chip CPU lainnya. Banyak program aplikasi yang ditulis untuk dijalankan pada CP/M, memungkinkannya untuk sepenuhnya mendominasi dunia mikrokomputer selama sekitar 5 tahun.

Pada awal 1980-an, IBM merancang PC IBM dan mencari-cari perangkat lunak untuk berlari di atasnya. Orang-orang dari IBM menghubungi Bill Gates untuk melisensikan penerjemah BASIC-nya. Mereka juga bertanya apakah dia tahu sistem operasi yang bisa dijalankan di PC. Gates menyarankan agar IBM menghubungi Digital Research, yang saat itu merupakan perusahaan sistem operasi yang dominan di dunia. Membuat apa yang pasti merupakan keputusan bisnis terburuk dalam mencatat sejarah, Kildall menolak bertemu dengan IBM, malah mengirim bawahan.

Lebih buruk lagi, pengacaranya bahkan menolak menandatangani kerahasiaan IBM perjanjian yang mencakup PC yang belum diumumkan. Akibatnya, IBM kembali ke Gates bertanya apakah dia bisa memberi mereka sistem operasi.

Ketika IBM kembali, Gates menyadari bahwa produsen komputer lokal, Seattle Computer Products, memiliki sistem operasi yang sesuai, DOS (Disk Operat ing System). Dia mendekati mereka dan meminta untuk membelinya (diduga seharga $75.000), yang mereka terima dengan senang hati. Gates kemudian menawarkan paket DOS/BASIC kepada IBM, yang diterima IBM. IBM menginginkan modifikasi tertentu, jadi Gates mempekerjakan orang yang menulis DOS, Tim Paterson, sebagai karyawan perusahaan baru Gates,

Microsoft, untuk membuatnya. Sistem yang direvisi diubah namanya menjadi MS-DOS (MicroSoft Disk Operating System) dan dengan cepat mendominasi pasar PC IBM. SEBUAH faktor kunci di sini adalah keputusan Gates (dalam retrospeksi, sangat bijaksana) untuk menjual MS-DOS ke perusahaan komputer untuk bundling dengan perangkat keras mereka, dibandingkan dengan Kildall's mencoba menjual CP/M kepada pengguna akhir satu per satu (setidaknya pada awalnya). Setelah semua ini terjadi, Kildall meninggal tiba-tiba dan tak terduga dari penyebab yang belum diungkapkan sepenuhnya.

Pada saat penerus IBM PC, IBM PC/AT, keluar pada tahun 1983 dengan CPU Intel 80286, MS-DOS tertanam kuat dan CP/M berada di posisinya kaki terakhir. MS-DOS kemudian banyak digunakan pada 80386 dan 80486. Meskipun versi awal MS-DOS cukup primitif, versi selanjutnya termasuk lebih banyak fitur-fitur canggih, termasuk banyak yang diambil dari UNIX. (Microsoft sangat menyadari UNIX, bahkan menjual versi mikrokomputer yang disebut XENIX selama tahun-tahun awal perusahaan.) CP/M, MS-DOS, dan sistem operasi lain untuk mikrokomputer awal adalah semua berdasarkan pengguna yang mengetikkan perintah dari keyboard. Itu akhirnya berubah karena penelitian yang dilakukan oleh Doug Engelbart di Stanford Research Institute di 1960-an. Engelbart menemukan Graphical User Interface, lengkap dengan windows, ikon, menu, dan mouse. Ide-ide ini diadopsi oleh para peneliti di Xerox PARC dan dimasukkan ke dalam mesin yang mereka buat.

Suatu hari, Steve Jobs, yang ikut menciptakan komputer Apple di garasinya, mengunjungi PARC, melihat GUI, dan langsung menyadari nilai potensialnya, sesuatu yang Xerox manajemen terkenal tidak. Kesalahan strategis dengan proporsi raksasa ini menghasilkan sebuah buku berjudul Meraba-raba Masa Depan (Smith dan Alexander, 1988). Pekerjaan kemudian memulai membangun Apple dengan GUI. Proyek ini mengarah ke Lisa, yang terlalu mahal dan gagal secara komersial. Upaya kedua Jobs, Apple Mac intosh, sukses besar, bukan hanya karena jauh lebih murah daripada Lisa, tetapi juga karena ramah pengguna, artinya ditujukan untuk pengguna yang tidak hanya tahu apa-apa tentang komputer tetapi lebih jauh lagi sama sekali tidak ada niat belajar apa pun. Dalam dunia kreatif desain grafis, profesional fotografi digital, dan produksi video digital profesional, Macintoshes adalah sangat banyak digunakan dan pengguna mereka sangat antusias tentang mereka. Pada tahun 1999, Apple mengadopsi kernel yang berasal dari mikrokernel Mach Universitas Carnegie Mellon yang awalnya dikembangkan untuk menggantikan kernel BSD UNIX. Jadi, Mac OS X adalah sistem operasi berbasis UNIX, meskipun dengan antarmuka yang sangat khas.

Ketika Microsoft memutuskan untuk membangun penerus MS-DOS, itu sangat dipengaruhi oleh keberhasilan Macintosh. Ini menghasilkan sistem berbasis GUI yang disebut ed Windows, yang awalnya berjalan di atas MS-DOS (yaitu, itu lebih seperti shell dari sistem operasi yang sebenarnya). Selama sekitar 10 tahun, dari 1985 hingga 1995, Windows hanyalah lingkungan grafis di atas MS-DOS. Namun, mulai tahun 1995 versi berdiri bebas, Windows 95, dirilis yang menggabungkan banyak operasi fitur sistem ke dalamnya, menggunakan sistem MS-DOS yang mendasarinya hanya untuk booting dan menjalankan program MS-DOS lama. Pada tahun 1998, versi yang sedikit dimodifikasi dari sistem ini, yang disebut Windows 98 dirilis. Namun demikian, baik Windows 95 dan Windows 98 masih berisi sejumlah besar bahasa rakitan Intel 16-bit.

Sistem operasi Microsoft lainnya, Windows NT (di mana NT adalah singkatan dari Teknologi Baru), yang kompatibel dengan Windows 95 pada tingkat tertentu, tetapi menulis ulang lengkap dari awal secara internal. Itu adalah sistem 32-bit penuh. Penandatangan utama untuk Windows NT adalah David Cutler, yang juga merupakan salah satu desainer dari Sistem operasi VAX VMS, jadi beberapa ide dari VMS hadir di NT. Faktanya, begitu banyak ide dari VMS yang hadir di dalamnya sehingga pemilik VMS, DEC, menggugat Microsoft. Kasus ini diselesaikan di luar pengadilan untuk sejumlah uang yang membutuhkan banyak angka untuk diekspresikan. Microsoft berharap bahwa versi pertama NT akan membunuh mematikan MS-DOS dan semua versi Windows lainnya karena ini adalah sistem yang jauh lebih unggul, tetapi gagal. Hanya dengan Windows NT 4.0 akhirnya berhasil, terutama pada jaringan perusahaan. Versi 5 Windows NT berganti nama menjadi Win dows 2000 pada awal 1999. Ini dimaksudkan untuk menjadi penerus kedua Windows 98 dan Windows NT 4.0.

Itu juga tidak berhasil, jadi Microsoft mengeluarkan versi lain dari Windows 98 yang disebut Windows Me (Edisi Milenium). Pada tahun 2001, sedikit upgrade versi Windows 2000, yang disebut Windows XP dirilis. Versi tersebut telah berjalan lebih lama (6 tahun), pada dasarnya menggantikan semua versi Windows sebelumnya. Masih pemijahan versi terus berlanjut. Setelah Windows 2000, Microsoft memecah keluarga Windows menjadi klien dan baris server. Klien baris didasarkan pada XP dan penerusnya, sedangkan baris server termasuk Windows Server 2003 dan Windows 2008. Baris ketiga, untuk dunia tertanam, muncul sebagain sedikit kemudian. Semua versi Windows ini mengubah variasinya dalam bentuk dari paket layanan. Itu sudah cukup untuk membuat beberapa administrator (dan penulis buku teks sistem operasi) nyaman.

Kemudian pada Januari 2007, Microsoft akhirnya merilis penerus Windows XP, disebut Vista. Itu datang dengan antarmuka grafis baru, keamanan yang ditingkatkan, dan banyak program pengguna baru atau yang ditingkatkan. Microsoft berharap itu akan menggantikan Windows XP sepenuhnya, tetapi tidak pernah berhasil. Sebaliknya, ia menerima banyak kritik dan pers yang buruk, sebagian besar karena persyaratan sistem yang tinggi, persyaratan lisensi yang ketat, dan dukungan untuk Manajemen Hak Digital, teknik yang mempersulit pengguna untuk menyalin materi yang dilindungi.

Dengan kedatangan Windows 7, versi baru yang haus sumber daya jauh lebih sedikit dari sistem operasi, banyak orang memutuskan untuk melewatkan Vista sama sekali. Windows 7 tidak memperkenalkan terlalu banyak fitur baru, tetapi relatif kecil dan cukup stabil. Dalam waktu kurang dari tiga minggu, Windows 7 telah memperoleh lebih banyak pangsa pasar daripada Vista dalam tujuh bulan. Pada tahun 2012, Microsoft meluncurkan penggantinya, Windows 8, dan sistem operasi dengan tampilan dan nuansa yang benar-benar baru, ditujukan untuk layar sentuh.

Perusahaan berharap bahwa desain baru akan menjadi sistem operasi yang dominan pada berbagai perangkat yang lebih luas: desktop, laptop, notebook, tablet, telepon, dan PC home theater. Namun sejauh ini penetrasi pasarnya lambat dibandingkan dengan Windows 7. Pesaing utama lainnya di dunia komputer pribadi adalah UNIX (dan berbagai turunan). UNIX adalah yang terkuat di server jaringan dan perusahaan tetapi juga sering hadir di komputer desktop, notebook, tablet, dan smartphone. Pada

komputer berbasis x86, Linux menjadi alternatif populer untuk Windows untuk pelajar dan pengguna korporat yang semakin banyak. Sebagai tambahan, di seluruh buku ini kita akan menggunakan istilah x86 untuk merujuk ke semua prosesor modern berdasarkan keluarga arsitektur set instruksi yang dimulai dengan 8086 pada 1970-an. Ada banyak prosesor seperti itu, yang diproduksi oleh perusahaan seperti AMD dan Intel, dan di bawah tenda mereka sering sangat berbeda: prosesor mungkin 32 bit atau 64 bit dengan sedikit atau banyak inti dan saluran pipa yang mungkin dalam atau dangkal, dan sebagainya. Namun demikian, bagi programmer, mereka semua terlihat cukup serupa dan semuanya masih dapat menjalankan kode 8086 yang ditulis 35 tahun yang lalu. Di mana perbedaannya penting, kami akan merujuk ke model eksplisit sebagai gantinya — dan gunakan x86-32 dan x86-64 untuk menunjukkan varian 32-bit dan 64-bit.

FreeBSD juga merupakan turunan UNIX yang populer, yang berasal dari proyek BSD di Berkeley. Semua komputer Macintosh modern menjalankan versi modifikasi dari FreeBSD (OSX). UNIX juga standar pada workstation yang didukung oleh kinerja tinggi chip RISC. Turunannya banyak digunakan pada perangkat seluler, seperti yang menjalankan iOS 7 atau Android. Banyak pengguna UNIX, terutama programmer berpengalaman, lebih memilih antarmuka berbasis perintah daripada GUI, sehingga hampir semua sistem UNIX mendukung sistem windowing. disebut X Window System (juga dikenal sebagai X11) yang diproduksi di M.I.T. Sistem ini menangani manajemen jendela dasar, memungkinkan pengguna untuk membuat, menghapus, memindahkan, dan mengubah ukuran jendela menggunakan mouse. Seringkali GUI lengkap, seperti Gnome atau KDE, tersedia untuk dijalankan di atas X11, memberikan UNIX tampilan dan rasa sesuatu seperti Macintosh atau Microsoft Windows, bagi para pengguna UNIX yang menginginkan hal.

Perkembangan menarik yang mulai terjadi pada pertengahan 1980-an adalah pertumbuhan jaringan komputer pribadi yang menjalankan sistem operasi jaringan dan sistem operasi terdistribusi (Tanenbaum dan Van Steen, 2007). Di sebuah sistem operasi jaringan, pengguna menyadari keberadaan beberapa komputer dan dapat masuk ke mesin jarak jauh dan menyalin file dari satu mesin ke mesin lainnya. Setiap mesin menjalankan sistem operasi lokalnya sendiri dan memiliki pengguna lokalnya sendiri (atau pengguna).

Sistem operasi jaringan pada dasarnya tidak berbeda dari sistem operasi prosesor tunggal. Mereka jelas membutuhkan pengontrol antarmuka jaringan dan beberapa perangkat lunak tingkat rendah untuk menjalankannya, serta program untuk mencapai login jarak jauh dan akses file jarak jauh, tetapi penambahan ini tidak mengubah struktur penting dari sistem operasi.

Sebuah sistem operasi terdistribusi, sebaliknya, adalah salah satu yang muncul kepada penggunanya sebagai sistem uniprosesor tradisional, meskipun sebenarnya terdiri dari beberapa prosesor. Pengguna seharusnya tidak mengetahui di mana program mereka dijalankan atau di mana file mereka berada; yang semuanya harus ditangani secara otomatis dan efisien oleh sistem operasi.

Sistem operasi terdistribusi sejati membutuhkan lebih dari sekadar menambahkan sedikit kode ke sistem operasi uniprosesor, karena sistem terdistribusi dan terpusat berbeda dalam cara-cara kritis tertentu. Sistem terdistribusi, misalnya, sering memungkinkan aplikasi untuk berjalan pada beberapa prosesor pada saat yang sama, sehingga membutuhkan lebih kompleks. algoritma penjadwalan prosesor untuk mengoptimalkan jumlah paralelisme. Keterlambatan komunikasi dalam jaringan sering berarti bahwa ini (dan lainnya) algoritma harus berjalan dengan informasi yang tidak lengkap, usang, atau bahkan salah. Ini situasi berbeda secara radikal dari sistem prosesor tunggal di mana sistem operasi memiliki informasi lengkap tentang status sistem.

### 1.2.5 Generasi Kelima (1990–Sekarang): Komputer Seluler

Sejak detektif Dick Tracy mulai berbicara dengan "pergelangan tangan radio dua arahnya menonton" di komik strip 1940-an, orang-orang mendambakan perangkat komunikasi mereka bisa dibawa kemanapun mereka pergi. Ponsel asli pertama muncul di 1946 dan beratnya sekitar 40 kilogram. Anda bisa membawanya ke mana pun Anda pergi selama Anda memiliki mobil untuk membawanya.

Telepon genggam pertama yang benar muncul pada tahun 1970-an dan, dengan berat kira-kira satu kilo gram, benar-benar kelas bulu. Itu dikenal sebagai "batu bata". Segera semua orang menginginkannya. Saat ini, penetrasi ponsel sudah dekat dengan 90% dari populasi dunia. Kami dapat melakukan panggilan tidak hanya dengan ponsel portabel kami dan jam tangan, tetapi segera dengan kacamata dan barang-barang yang dapat dikenakan lainnya. Lebih-lebih lagi, bagian telepon tidak lagi menarik. Kami menerima email, menjelajahi Web, SMS teman-teman kita, bermain game, bernavigasi di lalu lintas padat—dan bahkan tidak berpikir dua kali tentang itu.

Sementara gagasan menggabungkan telepon dan komputasi dalam perangkat seperti telepon telah ada sejak tahun 1970-an juga, smartphone asli pertama tidak muncul sampai pertengahan 1990-an ketika Nokia merilis N9000, yang secara harfiah menggabungkan dua, sebagian besar perangkat terpisah: telepon dan PDA (Personal Digital Assistant). Pada tahun 1997, Ericsson menciptakan istilah smartphone untuk GS88-nya "Penelope".

Sekarang smartphone telah menjadi di mana-mana, persaingan antara berbagai sistem operasi ganas dan hasilnya bahkan kurang jelas daripada di Dunia PC. Pada saat penulisan, Android Google adalah sistem operasi yang dominan dengan iOS Apple yang jelas kedua, tetapi ini tidak selalu terjadi dan semua mungkin menjadi berbeda lagi hanya dalam beberapa tahun. Jika ada yang jelas di dunia ponsel pintar, tidak mudah untuk tinggal lama di raja gunung.

Lagi pula, sebagian besar smartphone dalam dekade pertama setelah peluncurannya menjalankan OS Symbian. Itu adalah sistem operasi pilihan untuk merek populer seperti Samsung, Sony Ericsson, Motorola, dan terutama Nokia. Namun, sistem operasi lain seperti OS Blackberry RIM (diperkenalkan untuk smartphone pada tahun 2002) dan Apple iOS (dirilis untuk iPhone pertama pada tahun 2007) mulai memakan Symbian's saham. Banyak yang berharap RIM akan mendominasi pasar bisnis, sementara iOS akan menjadi raja perangkat konsumen. Plum pangsa pasar Symbian terpenuhi. Pada tahun 2011, Nokia membuang Symbian dan mengumumkan akan fokus pada Windows Phone sebagai platform utamanya. Untuk beberapa waktu, Apple dan RIM bersulang kota (walaupun tidak sedominan Symbian sebelumnya), tetapi tidak butuh waktu sangat lama untuk Android, sistem operasi berbasis Linux yang dirilis oleh Google di 2008, untuk menyalip semua saingannya.

Untuk produsen ponsel, Android memiliki keunggulan karena bersifat open source dan tersedia di bawah lisensi permisif. Akibatnya, mereka bisa mengotak-atiknya dan menyesuaikannya dengan perangkat keras mereka sendiri dengan mudah. Selain itu, ia memiliki komunitas besar pengembang aplikasi penulisan, sebagian besar dalam bahasa pemrograman Java yang sudah dikenal. Walaupun demikian, beberapa tahun terakhir telah menunjukkan bahwa dominasi mungkin tidak bertahan lama, dan pesaing Android sangat ingin merebut kembali sebagian dari pangsa pasarnya. Kami akan melihat Android di rinci di Sistem operasi terkait erat dengan perangkat keras komputer yang dijalankannya pada. Ini memperluas set instruksi komputer dan mengelola sumber dayanya. Bekerja, ia harus tahu banyak tentang perangkat keras, setidaknya tentang bagaimana perangkat keras itu tampak bagi programmer. Untuk alasan ini, mari kita tinjau secara singkat perangkat keras komputer seperti yang ditemukan di komputer pribadi modern. Setelah itu, kita dapat mulai masuk ke detail apa yang dilakukan sistem operasi dan bagaimana cara kerjanya.

## 1.3 TINJAUAN PERANGKAT KERAS KOMPUTER

Secara konseptual, komputer pribadi sederhana dapat diabstraksikan menjadi model yang mirip dengan Gambar 1-6. CPU, memori, dan perangkat I/O semuanya terhubung dengan sistem bus dan berkomunikasi satu sama lain di atasnya. 

Komputer pribadi modern memiliki struktur yang lebih rumit, yang melibatkan banyak bus, yang akan kita lihat nanti. Untuk saat ini, model ini akan cukup. Di bagian berikut, kami akan meninjau secara singkat komponen-komponen ini dan memeriksa beberapa masalah perangkat keras yang menjadi perhatian perancang sistem operasi. Tak perlu dikatakan, ini akan menjadi ringkasan yang sangat kompak. Banyak buku telah ditulis tentang masalah komputer perangkat keras dan organisasi komputer. Dua yang terkenal adalah oleh Tanenbaum dan Austin (2012) dan Patterson dan Hennessy (2013)

![image](https://user-images.githubusercontent.com/112523858/189246109-53febf0d-2758-45a9-86f0-d8080dae9326.png)

Gambar 1-6. Beberapa komponen komputer pribadi sederhana.

### 1.3.1 Prosesor

`Otak` komputer adalah CPU. Itu mengambil instruksi dari memori dan mengeksekusi mereka. Siklus dasar setiap CPU adalah mengambil instruksi pertama dari memori, decode untuk menentukan jenis dan operandnya, jalankan, dan kemudian mengambil, mendekode, dan menjalankan instruksi selanjutnya. Siklus tersebut diulangi sampai program selesai. Dengan cara ini, program dilakukan.

Setiap CPU memiliki serangkaian instruksi khusus yang dapat dieksekusi. Jadi x86 prosesor tidak dapat menjalankan program ARM dan prosesor ARM tidak dapat mengeksekusi program x86. Karena mengakses memori untuk mendapatkan instruksi atau kata data membutuhkan lebih lama dari mengeksekusi instruksi, semua CPU berisi beberapa register di dalamnya untuk menahan variabel kunci dan hasil sementara. Jadi set instruksi umumnya berisi instruksi untuk memuat kata dari memori ke dalam register, dan menyimpan kata dari register ke memori. Instruksi lain menggabungkan dua operan dari register, memori, atau keduanya menjadi hasil, seperti menambahkan dua kata dan menyimpan hasilnya dalam register atau memori.

Selain register umum yang digunakan untuk menyimpan variabel dan hasil sementara, kebanyakan komputer memiliki beberapa register khusus yang dapat dilihat oleh pemrogram. Salah satunya adalah program counter, yang berisi memori ad dress dari instruksi berikutnya yang akan diambil. Setelah instruksi itu diambil, penghitung program diperbarui untuk menunjuk ke penggantinya.

Register lain adalah penunjuk tumpukan, yang menunjuk ke atas arus menumpuk di memori. Tumpukan berisi satu frame untuk setiap prosedur yang telah masuk tapi belum keluar. Kerangka tumpukan prosedur menyimpan parameter input tersebut, variabel lokal, dan variabel sementara yang tidak disimpan dalam register. Namun register lain adalah PSW (Program Status Word). Register ini berisi bit kode kondisi, yang diatur oleh instruksi perbandingan, CPU prioritas, mode (pengguna atau kernel), dan berbagai bit kontrol lainnya. Program pengguna biasanya dapat membaca seluruh PSW tetapi biasanya hanya dapat menulis beberapa bidangnya.

PSW memainkan peran penting dalam panggilan sistem dan I/O. Sistem operasi harus sepenuhnya menyadari semua register. Ketika waktu mul memberi tip pada CPU, sistem operasi akan sering menghentikan program yang sedang berjalan untuk (kembali) mulai yang lain. Setiap kali menghentikan program yang sedang berjalan, sistem operasi harus menyimpan semua register agar dapat dipulihkan saat program berjalan nanti.

Untuk meningkatkan kinerja, desainer CPU telah lama meninggalkan yang sederhana model pengambilan, decoding, dan eksekusi satu instruksi pada satu waktu. Banyak modern CPU memiliki fasilitas untuk mengeksekusi lebih dari satu instruksi secara bersamaan. Untuk misalnya, CPU mungkin memiliki unit pengambilan, dekode, dan eksekusi terpisah, sehingga saat itu mengeksekusi instruksi n, bisa juga decoding instruksi n + 1 dan mengambil instruksi n + 2. Organisasi seperti itu disebut pipa dan diilustrasikan dalam

![image](https://user-images.githubusercontent.com/112523858/189246260-21fd018e-1db0-4b1b-985e-133b04c4c6b3.png)

Gambar 1-7(a) untuk pipa dengan tiga tahap. Pipa yang lebih panjang adalah hal biasa. Di sebagian besar desain pipa, setelah instruksi telah diambil ke dalam pipa, itu harus dieksekusi, bahkan jika instruksi sebelumnya adalah cabang bersyarat yang diambil.

Pipeline menyebabkan penulis kompiler dan penulis sistem operasi sakit kepala karena mereka mengekspos kompleksitas mesin yang mendasarinya kepada mereka dan mereka harus berurusan dengan mereka.Gambar 1-7. (a) Pipa tiga tahap. (b) CPU superskalar.

Bahkan lebih canggih dari desain pipa adalah CPU superscalar, ditunjukkan pada Gambar 1-7(b). Dalam desain ini, beberapa unit eksekusi hadir, misalnya, satu untuk aritmatika bilangan bulat, satu untuk aritmatika titik-mengambang, dan satu untuk operasi Boolean. Dua atau lebih instruksi diambil sekaligus, didekode, dan dibuang ke menahan buffer sampai dapat dieksekusi. Segera setelah unit eksekusi menjadi tersedia, itu terlihat di buffer holding untuk melihat apakah ada instruksi yang dapat ditangani le, dan jika demikian, ia menghapus instruksi dari buffer dan mengeksekusinya. Implikasi dari desain ini adalah bahwa instruksi program sering kali dieksekusi secara tidak berurutan. Untuk sebagian besar terserah perangkat keras untuk memastikan hasil yang dihasilkan sama satu implementasi berurutan akan menghasilkan, tetapi jumlah yang mengganggu kompleksitas dimasukkan ke sistem operasi, seperti yang akan kita lihat.

Sebagian besar CPU, kecuali yang sangat sederhana yang digunakan dalam sistem tertanam, memiliki dua mode, mode kernel dan mode pengguna, seperti yang disebutkan sebelumnya. Biasanya, sedikit di PSW mengontrol mode. Saat berjalan dalam mode kernel, CPU dapat mengeksekusi setiap instruksi dalam set instruksinya dan menggunakan setiap fitur perangkat keras. Di desktop dan mesin server, sistem operasi biasanya berjalan dalam mode kernel, memberikannya akses ke perangkat keras lengkap. Pada sebagian besar sistem tertanam, sebagian kecil berjalan dalam mode kernel, dengan sistem operasi lainnya berjalan dalam mode pengguna.

Program pengguna selalu berjalan dalam mode pengguna, yang memungkinkan hanya sebagian dari instruksi yang akan dieksekusi dan sebagian fitur yang akan diakses. Umumnya semua instruksi yang melibatkan I/O dan perlindungan memori tidak diizinkan dalam mode pengguna.

Mengatur bit mode PSW untuk masuk ke mode kernel juga dilarang, tentu saja. Untuk mendapatkan layanan dari sistem operasi, program pengguna harus membuat panggilan sistem, yang menjebak ke dalam kernel dan memanggil sistem operasi. Jebakan instruksi beralih dari mode pengguna ke mode kernel dan memulai sistem operasi. Ketika pekerjaan telah selesai, kontrol dikembalikan ke program pengguna di instruksi setelah panggilan sistem. Kami akan menjelaskan detail sistemnya mekanisme panggilan nanti dalam bab ini. Untuk saat ini, anggap itu sebagai jenis khusus panggilan prosedur yang memiliki properti tambahan untuk beralih dari mode pengguna ke modus inti. Sebagai catatan tentang tipografi, kami akan menggunakan huruf kecil Helvetica font untuk menunjukkan panggilan sistem dalam teks yang sedang berjalan, seperti ini: baca.

Perlu dicatat bahwa komputer memiliki jebakan selain instruksi untuk menjalankan panggilan sistem. Sebagian besar jebakan lain disebabkan oleh perangkat keras untuk memperingatkan dari situasi luar biasa seperti upaya untuk membagi dengan 0 atau floating-point arus bawah. Dalam semua kasus, sistem operasi mendapat kendali dan harus memutuskan apa yang harus melakukan. Terkadang program harus dihentikan dengan kesalahan. Di lain waktu kesalahan dapat diabaikan (angka underflow dapat diatur ke 0). Akhirnya, ketika program telah mengumumkan sebelumnya bahwa ia ingin menangani jenis kondisi tertentu, kontrol dapat diteruskan kembali ke program untuk membiarkannya menangani masalah.

_Chip Multithread dan Multicore_

Hukum Moore menyatakan bahwa jumlah transistor pada sebuah chip berlipat ganda setiap 18 bulan. ''Hukum'' ini bukanlah semacam hukum fisika, seperti kekekalan momentum, tetapi merupakan pengamatan oleh salah satu pendiri Intel, Gordon Moore, tentang seberapa cepat insinyur proses di perusahaan semikonduktor mampu mengecilkan transistor mereka.

Hukum Moore telah berlaku selama lebih dari tiga dekade sekarang dan diperkirakan akan berlaku selama setidaknya satu lagi. Setelah itu, jumlah atom per transistor akan menjadi terlalu mekanika kecil dan kuantum akan mulai memainkan peran besar, mencegah lebih lanjut penyusutan ukuran transistor 

Kelimpahan transistor menyebabkan masalah: apa yang harus dilakukan dengan semua mereka? Kami melihat satu pendekatan di atas: arsitektur superscalar, dengan beberapa unit fungsional. Tetapi karena jumlah transistor meningkat, lebih banyak lagi yang mungkin. Satu hal yang jelas untuk dilakukan adalah meletakkan cache yang lebih besar pada chip CPU. Itu pasti terjadi, tetapi pada akhirnya titik hasil yang semakin berkurang akan tercapai.

Langkah selanjutnya yang jelas adalah mereplikasi tidak hanya unit fungsional, tetapi juga beberapa logika kontrol. Intel Pentium 4 memperkenalkan properti ini, yang disebut multithreading atau hyperthreading (nama Intel untuk itu), ke prosesor x86, dan beberapa chip CPU lainnya juga memilikinya—termasuk SPARC, Power5, Intel Xeon, dan keluarga Intel Core. Untuk pendekatan pertama, apa yang dilakukannya adalah mengizinkan CPU untuk menahan status dua utas yang berbeda dan kemudian beralih bolak-balik pada skala waktu nanodetik. (Utas adalah sejenis proses ringan, yang, pada gilirannya, adalah program yang sedang berjalan; kita akan masuk ke rincian di Chap. 2.) Misalnya, jika salah satu proses perlu membaca kata dari memori (yang membutuhkan banyak jam siklus), CPU multithreaded hanya dapat beralih ke thread lain. Multithreading tidak menawarkan paralelisme sejati. Hanya satu proses pada satu waktu yang berjalan, tapi waktu thread-switching berkurang ke urutan nanodetik.

Multithreading memiliki implikasi untuk sistem operasi karena setiap thread muncul ke sistem operasi sebagai CPU terpisah. Pertimbangkan sistem dengan dua CPU sebenarnya, masing-masing dengan dua utas. Sistem operasi akan melihat ini sebagai empat CPU. Jika hanya ada cukup pekerjaan untuk membuat dua CPU sibuk pada titik tertentu di waktu, mungkin secara tidak sengaja menjadwalkan dua utas pada CPU yang sama, dengan yang lain CPU benar-benar menganggur. Pilihan ini jauh kurang efisien daripada menggunakan satu utas pada masing-masing CPU.

Selain multithreading, banyak chip CPU sekarang memiliki empat, delapan, atau lebih prosesor atau inti lengkap. Chip multicore pada Gambar 1-8 secara efektif membawa empat minichip di dalamnya, masing-masing dengan CPU independennya sendiri. (Cache akan menjadi dijelaskan di bawah ini.) Beberapa prosesor, seperti Intel Xeon Phi dan Tilera TilePro, sudah siap menjalankan lebih dari 60 core dalam satu chip. Memanfaatkan multicore seperti itu chip pasti akan membutuhkan sistem operasi multiprosesor.

Kebetulan, dalam hal jumlah, tidak ada yang mengalahkan GPU modern (Graph ics Processing Unit). GPU adalah prosesor dengan, secara harfiah, ribuan inti kecil.

Mereka sangat bagus untuk banyak perhitungan kecil yang dilakukan secara paralel, seperti rendering poligon dalam aplikasi grafis. Mereka tidak begitu baik dalam tugas-tugas serial. Mereka juga sulit untuk diprogram. Meskipun GPU dapat berguna untuk sistem operasi (mis., enkripsi atau pemrosesan lalu lintas jaringan), tidak mungkin sebagian besar operasi sistem itu sendiri akan berjalan di GPU.

![Gambar1-8](https://user-images.githubusercontent.com/112523858/189533159-301d2bd2-4608-411a-841b-14c5f866052e.JPG)

Gambar 1-8. (a) Chip quad-core dengan cache L2 bersama. (b) Sebuah chip quad-core dengan cache L2 terpisah.

### 1.3.2 Memori

Komponen utama kedua di komputer manapun adalah memori. Idealnya, memori harus sangat cepat (lebih cepat daripada mengeksekusi instruksi sehingga CPU dapat tidak tertahan oleh memori), sangat besar, dan sangat murah. Tidak ada teknologi saat ini yang memenuhi semua tujuan ini, sehingga diambil pendekatan yang berbeda. Sistem memori dibangun sebagai hierarki lapisan, seperti yang ditunjukkan pada 

![image](https://user-images.githubusercontent.com/112523858/189533648-6baca221-e997-4c6f-ab71-a137ca8227cc.png)

Gambar 1-9. Lapisan atas memiliki kecepatan lebih tinggi, kapasitas lebih kecil, dan biaya per bit lebih besar daripada yang lebih rendah, sering kali dengan faktor satu miliar atau lebih. Lapisan atas terdiri dari register internal ke CPU. Mereka terbuat dari bahan yang sama dengan CPU dan dengan demikian secepat CPU. Akibatnya, tidak ada penundaan dalam mengaksesnya. Kapasitas penyimpanan yang tersedia di dalamnya adalah Gambar 1-9. Hirarki memori yang khas. Angka-angka adalah perkiraan yang sangat kasar. biasanya 32 × 32 bit pada CPU 32-bit dan 64 × 64 bit pada CPU 64-bit. Kurang dari 1 KB dalam kedua kasus. Program harus mengelola register (yaitu, memutuskan apa yang harus disimpan di dalamnya) sendiri, dalam perangkat lunak.

Berikutnya adalah memori cache, yang sebagian besar dikendalikan oleh perangkat keras. Memori utama dibagi menjadi baris cache, biasanya 64 byte, dengan alamat 0 ke 63 di baris cache 0, 64 hingga 127 di cache baris 1, dan seterusnya. Yang paling banyak digunakan baris cache disimpan dalam cache berkecepatan tinggi yang terletak di dalam atau sangat dekat dengan CPU.

Ketika program perlu membaca kata memori, perangkat keras cache memeriksa untuk melihat jika baris yang dibutuhkan ada di cache. Jika ya, disebut cache hit, permintaannya terpenuhi dari cache dan tidak ada permintaan memori yang dikirim melalui bus ke memori utama. Cache hits biasanya memakan waktu sekitar dua siklus clock. Cache rindu harus pergi ke memori, dengan hukuman waktu yang substansial. Memori cache terbatas ukurannya karena harga tinggi. Beberapa mesin memiliki dua atau bahkan tiga tingkat cache, masing-masing lebih lambat dan lebih besar dari yang sebelumnya. Caching memainkan peran utama dalam banyak bidang ilmu komputer, bukan hanya caching baris RAM. Setiap kali sumber daya dapat dibagi menjadi beberapa bagian, beberapa di antaranya adalah digunakan jauh lebih banyak daripada yang lain, caching sering digunakan untuk meningkatkan kinerja. Sistem operasi menggunakannya sepanjang waktu. Misalnya, sebagian besar sistem operasi simpan (potongan) file yang banyak digunakan di memori utama untuk menghindari keharusan mengambilnya dari disk berulang kali. Demikian pula, hasil konversi nama jalur panjang seperti /home/ast/projects/minix3/src/kernel/clock.com ke alamat disk tempat file berada dapat di-cache untuk menghindari pengulangan pencarian. Akhirnya, ketika alamat halaman Web (URL) dikonversi ke jaringan address (alamat IP), hasilnya dapat di-cache untuk digunakan di masa mendatang. Banyak kegunaan lain yang ada.

Dalam sistem caching apa pun, beberapa pertanyaan segera muncul, termasuk:
1. Kapan harus memasukkan item baru ke dalam cache.
2. Baris cache mana untuk memasukkan item baru.
3. Item mana yang harus dihapus dari cache saat slot diperlukan.
4. Tempat meletakkan item yang baru dikeluarkan di memori yang lebih besar.

Tidak setiap pertanyaan relevan dengan setiap situasi caching. Untuk caching baris main memori dalam cache CPU, item baru umumnya akan dimasukkan pada setiap cache merindukan. Garis cache yang digunakan umumnya dihitung dengan menggunakan beberapa perintah tingkat tinggi bit alamat memori yang dirujuk. Misalnya, dengan 4096 baris cache 64 byte dan alamat 32 bit, bit 6 hingga 17 dapat digunakan untuk menentukan cache baris, dengan bit 0 sampai 5 byte dalam baris cache. Dalam hal ini, item yang akan dihapus sama dengan data baru yang masuk, tetapi di sistem lain mungkin tidak.

Akhirnya, ketika baris cache ditulis ulang ke memori utama (jika telah dimodifikasi sejak di-cache), tempat di memori untuk menulis ulang ditentukan secara unik oleh alamat yang dimaksud. Cache adalah ide yang bagus sehingga CPU modern memiliki dua di antaranya. Pertama cache level atau L1 selalu berada di dalam CPU dan biasanya memberikan instruksi yang didekodekan ke mesin eksekusi CPU. Sebagian besar chip memiliki cache L1 kedua untuk waktu yang sangat lama kata-kata data yang banyak digunakan. Cache L1 biasanya masing-masing 16 KB. Sebagai tambahan, sering ada cache kedua, yang disebut cache L2, yang menampung beberapa megabita kata-kata memori yang baru-baru ini digunakan. Perbedaan antara cache L1 dan L2 terletak pada waktunya. Akses ke cache L1 dilakukan tanpa penundaan, sedangkan akses ke cache L2 melibatkan penundaan satu atau dua siklus clock.

Pada chip multicore, perancang harus memutuskan di mana menempatkan cache. Di Gambar 1-8(a), satu cache L2 digunakan bersama oleh semua inti. Pendekatan ini digunakan dalam Chip multicore Intel. Sebaliknya, pada Gambar 1-8(b), setiap inti memiliki cache L2 sendiri.

Pendekatan ini digunakan oleh AMD. Setiap strategi memiliki pro dan kontra. Sebagai contoh, cache L2 bersama Intel membutuhkan pengontrol cache yang lebih rumit tetapi Cara AMD membuat cache L2 tetap konsisten menjadi lebih sulit. Memori utama muncul berikutnya dalam hierarki Gambar 1-9. Ini adalah pekerja keras dari sistem memori. Memori utama biasanya disebut RAM (Random Access) Penyimpanan). Orang tua terkadang menyebutnya memori inti, karena komputer di 1950-an dan 1960-an menggunakan inti ferit kecil yang dapat dimagnetisasi untuk memori utama. Mereka memiliki telah hilang selama beberapa dekade tetapi namanya tetap ada. Saat ini, kenangan adalah ratusan megabyte hingga beberapa gigabyte dan berkembang pesat. Semua permintaan CPU yang tidak bisa puas keluar dari cache pergi ke memori utama.

Selain memori utama, banyak komputer memiliki sejumlah kecil memori akses acak yang tidak mudah menguap. Tidak seperti RAM, memori nonvolatile tidak hilang isinya saat listrik dimatikan. ROM (Memori Hanya Baca) diprogram di pabrik dan tidak dapat diubah setelahnya. Ini cepat dan murah. Pada beberapa komputer, bootstrap loader yang digunakan untuk memulai komputer terdapat dalam ROM.

Juga, beberapa kartu I/O dilengkapi dengan ROM untuk menangani kontrol perangkat tingkat rendah. EEPROM (Electrically Erasable PROM) dan memori flash juga bersifat non volatile, namun berbeda dengan ROM yang dapat dihapus dan ditulis ulang. Namun, menulis mereka membutuhkan waktu lebih lama daripada menulis RAM, jadi mereka digunakan dalam ROM dengan cara yang sama, hanya dengan fitur tambahan yang sekarang dimungkinkan untuk memperbaiki bug dalam program yang mereka pegang dengan menulis ulang di lapangan.

Flash memory juga biasa digunakan sebagai media penyimpanan pada perangkat elektronik portabel. Ini berfungsi sebagai film di kamera digital dan sebagai disk dalam musik portabel pemain, untuk menyebutkan hanya dua kegunaan. Memori flash memiliki kecepatan menengah antara RAM dan disk. Juga, tidak seperti memori disk, jika terlalu sering dihapus, itu akan aus keluar.

Namun jenis memori lain adalah CMOS, yang tidak stabil. Banyak komputer menggunakan Memori CMOS untuk menyimpan waktu dan tanggal saat ini. Memori CMOS dan rangkaian jam yang menambah waktu di dalamnya ditenagai oleh baterai kecil, jadi waktu diperbarui dengan benar, bahkan ketika komputer dicabut. Memori CMOS juga dapat menyimpan parameter konfigurasi, seperti disk mana yang akan di-boot.

CMOS digunakan karena menggunakan daya yang sangat kecil sehingga yang dipasang di pabrik asli baterai sering berlangsung selama beberapa tahun. Namun, ketika mulai gagal, komputer tampaknya memiliki penyakit Alzheimer, melupakan hal-hal yang telah diketahuinya tahun, seperti hard disk mana untuk boot.

### 1.3.3 Disk

Berikutnya dalam hirarki adalah magnetic disk (hard disk). Penyimpanan disk adalah dua pesanan besarnya lebih murah daripada RAM per bit dan seringkali dua kali lipat lebih besar demikian juga. Satu-satunya masalah adalah waktu untuk mengakses data secara acak di dekat tiga kali lipat lebih lambat. Alasannya adalah bahwa disk adalah perangkat mekanis, seperti yang ditunjukkan pada Gambar 1-10.

![image](https://user-images.githubusercontent.com/112523858/189534044-753b20b4-cb82-4c03-9049-b77525432faa.png)

Gambar 1-10. Struktur disk drive.
Sebuah piringan terdiri dari satu atau lebih pelat logam yang berputar pada 5400, 7200, 10,800
RPM atau lebih. Lengan mekanis berputar di atas piring-piring dari sudut, serupa
ke lengan pickup pada fonograf 33-RPM tua untuk memutar piringan hitam.

Informasi ditulis ke disk dalam serangkaian lingkaran konsentris. Kapan saja posisi lengan, masing-masing kepala dapat membaca daerah annular yang disebut trek. Untuk mendapatkannya, semua trek untuk posisi lengan tertentu membentuk silinder.

Setiap trek dibagi menjadi beberapa sektor, biasanya 512 byte per detik. Pada disk modern, silinder luar berisi lebih banyak sektor daripada yang dalam. Memindahkan lengan dari satu silinder ke silinder berikutnya membutuhkan waktu sekitar 1 mdtk. Memindahkannya ke silinder acak biasanya membutuhkan waktu 5 sampai 10 msec, tergantung pada drive. sekali lengan berada di jalur yang benar, drive harus menunggu sektor yang diperlukan berputar di bawah kepala, penundaan tambahan dari 5 mdtk hingga 10 mdtk, tergantung pada RPM drive.

Setelah sektor berada di bawah kepala, membaca atau menulis terjadi pada kecepatan 50 MB/dtk pada disk kelas bawah hingga 160 MB/detik pada disk yang lebih cepat. Terkadang Anda akan mendengar orang berbicara tentang disk yang sebenarnya bukan disk sama sekali, seperti SSD, (Solid State Disk). SSD tidak memiliki bagian yang bergerak, tidak mengandung piring-piring dalam bentuk disk, dan menyimpan data dalam memori (Flash). Satu-satunya cara masuk yang menyerupai disk adalah mereka juga menyimpan banyak data yang tidak hilang saat listrik mati.

Banyak komputer mendukung skema yang dikenal sebagai memori virtual, yang akan kita membahas panjang lebar di Bab. 3. Skema ini memungkinkan untuk menjalankan program lebih besar dari memori fisik dengan menempatkannya pada disk dan menggunakan memori utama sebagai semacam cache untuk bagian yang paling banyak dieksekusi. Skema ini membutuhkan pemetaan ulang alamat memori dengan cepat untuk mengubah alamat program yang dihasilkan ke alamat fisik di RAM tempat kata berada. pemetaan ini adalah dilakukan oleh bagian dari CPU yang disebut MMU (Memory Management Unit), sebagai ditunjukkan pada Gambar. 1-6.

Kehadiran caching dan MMU dapat berdampak besar pada kinerja. Dalam sistem multiprogramming, ketika beralih dari satu program ke lain, kadang-kadang disebut sakelar konteks, mungkin perlu untuk menghapus semua blok yang dimodifikasi dari cache dan mengubah register pemetaan di MMU. Keduanya ini adalah operasi yang mahal, dan pemrogram berusaha keras untuk menghindarinya. Kami akan lihat beberapa implikasi dari taktik mereka nanti.

### 1.3.4 Perangkat I/O

CPU dan memori bukan satu-satunya sumber daya yang dimiliki sistem operasi harus mengelola. Perangkat I/O juga banyak berinteraksi dengan sistem operasi. Seperti yang kita dilihat pada Gambar 1-6, perangkat I/O umumnya terdiri dari dua bagian: pengontrol dan perangkat itu sendiri. Controller adalah sebuah chip atau satu set chip yang secara fisik mengontrol perangkat. Ia menerima perintah dari sistem operasi, misalnya, untuk membaca data dari perangkat, dan melaksanakannya.

Dalam banyak kasus, kontrol perangkat yang sebenarnya rumit dan terperinci, jadi itu adalah tugas pengontrol untuk menghadirkan antarmuka yang lebih sederhana (tetapi masih sangat kompleks) ke sistem operasi. Misalnya, pengontrol disk mungkin menerima perintah untuk baca sektor 11.206 dari disk 2. Pengontrol kemudian harus mengubah sektor linier ini nomor ke silinder, sektor, dan kepala. Konversi ini mungkin rumit oleh fakta bahwa silinder luar memiliki lebih banyak sektor daripada yang dalam dan bahwa beberapa sektor buruk telah dipetakan kembali ke yang lain. Kemudian pengontrol harus menentukan silinder mana lengan disk berada dan berikan perintah untuk bergerak masuk atau keluar jumlah silinder yang diperlukan. Itu harus menunggu sampai sektor yang tepat diputar di bawah kepala dan kemudian mulai membaca dan menyimpan bit saat keluar dari drive, menghapus pembukaan dan menghitung checksum. Akhirnya, itu harus dirakit bit yang masuk ke dalam kata-kata dan menyimpannya dalam memori. Untuk melakukan semua pekerjaan ini, pengontrol sering kali berisi komputer kecil yang disematkan yang diprogram untuk melakukannya kerja.

Bagian lainnya adalah perangkat itu sendiri. Perangkat memiliki antarmuka yang cukup sederhana, baik karena tidak dapat berbuat banyak maupun untuk menjadikannya standar. Yang terakhir adalah diperlukan agar setiap pengontrol disk SATA dapat menangani disk SATA, misalnya. SATA adalah singkatan dari Serial ATA dan AT A pada gilirannya adalah singkatan dari AT Attachment. Dalam hal Anda ingin tahu apa singkatan dari AT, ini adalah generasi kedua IBM "Pribadi Teknologi Canggih Komputer" dibangun di sekitar 6-MHz yang sangat kuat saat itu.

Prosesor 80286 yang diperkenalkan perusahaan pada tahun 1984. Apa yang kami pelajari dari ini adalah bahwa industri komputer memiliki kebiasaan untuk terus menyempurnakan akronim yang ada dengan awalan dan akhiran baru. Kami juga belajar bahwa kata sifat seperti "ad vanced" harus digunakan dengan sangat hati-hati, atau Anda akan terlihat konyol tiga puluh tahun ke depan garis.

SATA saat ini merupakan jenis disk standar di banyak komputer. Karena antarmuka perangkat yang sebenarnya tersembunyi di balik pengontrol, semua itu adalah sistem operasi melihat adalah antarmuka ke pengontrol, yang mungkin sangat berbeda dari antarmuka ke perangkat. Karena setiap jenis pengontrol berbeda, perangkat lunak yang berbeda diperlukan untuk mengontrol masing-masing. Perangkat lunak yang berbicara dengan pengontrol, memberinya perintah dan menerima tanggapan, disebut driver perangkat. Setiap produsen pengontrol harus menyediakan driver untuk setiap sistem operasi yang didukungnya. Jadi pemindai mungkin datang dengan driver untuk OS X, Windows 7, Windows 8, dan Linux, misalnya.

Untuk menggunakannya, driver harus dimasukkan ke dalam sistem operasi agar dapat berjalan di modus inti. Driver benar-benar dapat berjalan di luar kernel, dan sistem operasi seperti Linux dan Windows saat ini menawarkan beberapa dukungan untuk melakukannya. Yang luas sebagian besar driver masih berjalan di bawah batas kernel. Hanya sangat sedikit saat ini sistem, seperti MINIX 3, menjalankan semua driver di ruang pengguna. Pengemudi di ruang pengguna harus diizinkan untuk mengakses perangkat dengan cara yang terkontrol, yang tidak mudah.

Ada tiga cara driver dapat dimasukkan ke dalam kernel. Cara pertama adalah hubungkan kembali kernel dengan driver baru dan kemudian reboot sistem. Banyak UNIX yang lebih tua sistem bekerja seperti ini. Cara kedua adalah membuat entri di sistem operasi file yang mengatakan bahwa itu membutuhkan driver dan kemudian reboot sistem. Pada saat booting, sistem operasi berjalan dan menemukan driver yang dibutuhkan dan memuatnya. jendela bekerja dengan cara ini. Cara ketiga adalah agar sistem operasi dapat menerima yang baru driver saat menjalankan dan menginstalnya dengan cepat tanpa perlu reboot. Ini cara yang dulunya jarang tetapi sekarang menjadi jauh lebih umum. Hot-pluggable perangkat, seperti perangkat USB dan IEEE 1394 (dibahas di bawah), selalu membutuhkan driver yang dimuat secara dinamis.

Setiap pengontrol memiliki sejumlah kecil register yang digunakan untuk berkomunikasi dengan itu. Misalnya, pengontrol disk minimal mungkin memiliki register untuk menentukan alamat disk, alamat memori, jumlah sektor, dan arah (baca atau tulis). Ke aktifkan pengontrol, pengemudi mendapat perintah dari sistem operasi, lalu menerjemahkannya ke dalam nilai yang sesuai untuk ditulis ke dalam register perangkat. Koleksi semua register perangkat membentuk ruang port I/O, topik yang akan kita bahas kembali ke dalam Bab. 5.

Pada beberapa komputer, register perangkat dipetakan ke dalam ruang alamat sistem operasi (alamat yang dapat digunakan), sehingga dapat dibaca dan ditulis seperti kata-kata memori biasa. Pada komputer seperti itu, tidak diperlukan instruksi I/O khusus dan program pengguna dapat dijauhkan dari perangkat keras dengan tidak meletakkannya alamat memori dalam jangkauan mereka (misalnya, dengan menggunakan register dasar dan batas). Pada komputer lain, register perangkat diletakkan di ruang port I/O khusus, dengan masing-masing mendaftar memiliki alamat port. Pada mesin ini, instruksi IN dan OUT khusus tersedia dalam mode kernel untuk memungkinkan driver membaca dan menulis register.

skema sebelumnya menghilangkan kebutuhan untuk instruksi I/O khusus tetapi menggunakan beberapa dari ruang alamat. Yang terakhir tidak menggunakan ruang alamat tetapi membutuhkan instruksi khusus. Kedua sistem ini banyak digunakan. Input dan output dapat dilakukan dengan tiga cara berbeda. Dalam metode yang paling sederhana, program pengguna mengeluarkan panggilan sistem, yang kemudian diterjemahkan oleh kernel ke dalam prosedur hubungi pengemudi yang sesuai. Pengemudi kemudian memulai I/O dan duduk dalam lingkaran yang ketat terus melakukan polling perangkat untuk melihat apakah sudah selesai (biasanya ada beberapa bit yang menunjukkan bahwa perangkat masih sibuk). Ketika I/O telah selesai, driver menempatkan data (jika ada) di mana mereka dibutuhkan dan dikembalikan. Sistem operasi kemudian mengembalikan kontrol ke pemanggil. Metode ini disebut sibuk menunggu dan memiliki keuntungan mengikat CPU polling perangkat sampai selesai.

Metode kedua adalah driver untuk memulai perangkat dan memintanya untuk memberikan interupsi ketika selesai. Pada saat itu pengemudi kembali. Sistem operasi kemudian memblokir penelepon jika perlu dan mencari pekerjaan lain yang harus dilakukan. Ketika pengontrol mendeteksi akhir transfer, itu menghasilkan interupsi untuk menyelesaikan sinyal.

Interupsi sangat penting dalam sistem operasi, jadi mari kita periksa idenya lebih dekat. Pada Gambar 1-11(a) kita melihat proses tiga langkah untuk I/O. Pada langkah 1, driver memberi tahu pengontrol apa yang harus dilakukan dengan menulis ke register perangkatnya. Pengendali kemudian memulai perangkat. Ketika pengontrol selesai membaca atau menulis jumlah byte yang telah diperintahkan untuk ditransfer, itu menandakan pengontrol interupsi chip menggunakan jalur bus tertentu pada langkah 2. Jika pengontrol interupsi siap menerima interupsi (yang mungkin tidak jika sedang sibuk menangani yang berprioritas lebih tinggi), ia memberikan pin pada chip CPU yang memberitahukannya, pada langkah 3. Pada langkah 4, pengontrol interupsi menempatkan nomor perangkat di bus sehingga CPU dapat membacanya dan mengetahui yang mana perangkat baru saja selesai (banyak perangkat mungkin berjalan pada waktu yang sama).

![image](https://user-images.githubusercontent.com/112523858/189534107-454743df-3328-4231-a4c4-9189b55b934f.png)

Gambar 1-11. (a) Langkah-langkah dalam memulai perangkat I/O dan mendapatkan interupsi. (b) Pemrosesan interupsi melibatkan pengambilan interupsi, menjalankan penangan interupsi,dan kembali ke program pengguna.

Setelah CPU memutuskan untuk mengambil interupsi, penghitung program dan PSW biasanya kemudian didorong ke tumpukan saat ini dan CPU beralih ke kernel mode. Nomor perangkat dapat digunakan sebagai indeks ke bagian memori untuk menemukan alamat pengendali interupsi untuk perangkat ini. Bagian memori ini disebut vektor interupsi. Setelah penangan interupsi (bagian dari driver untuk interupsi perangkat) telah dimulai, akan menghapus penghitung program yang ditumpuk dan PSW dan menyimpan mereka, lalu menanyakan perangkat untuk mempelajari statusnya. Ketika pawang sudah selesai, itu kembali ke program pengguna yang berjalan sebelumnya ke instruksi pertama yang tidak belum dieksekusi. Langkah-langkah ini ditunjukkan pada Gambar 1-11(b).

Metode ketiga untuk melakukan I/O menggunakan perangkat keras khusus: DMA (Direct Memory Access) chip yang dapat mengontrol aliran bit antar memori dan beberapa pengontrol tanpa intervensi CPU yang konstan. CPU mengatur Chip DMA, memberi tahu berapa banyak byte yang akan ditransfer, perangkat dan alamat memori terlibat, dan arahnya, dan membiarkannya pergi. Ketika chip DMA selesai, itu menyebabkan interupsi, yang ditangani seperti dijelaskan di atas. DMA dan perangkat keras I/O secara umum akan dibahas lebih rinci pada Bab. 5.

Interupsi dapat (dan sering terjadi) terjadi pada saat-saat yang sangat tidak nyaman, misalnya, saat penangan interupsi lain sedang berjalan. Untuk alasan ini, CPU memiliki cara untuk menonaktifkan interupsi dan kemudian mengaktifkannya kembali nanti. Saat interupsi dinonaktifkan, perangkat apa pun yang selesai melanjutkan untuk menegaskan sinyal interupsinya, tetapi CPU tidak terputus sampai interupsi diaktifkan kembali. Jika beberapa perangkat selesai saat interupsi dinonaktifkan, pengontrol interupsi memutuskan mana yang akan dibiarkan melalui pertama, biasanya berdasarkan prioritas statis yang ditetapkan untuk setiap perangkat. Itu perangkat dengan prioritas tertinggi menang dan akan diservis terlebih dahulu. Yang lain harus menunggu.

### 1.3.5 Bus

Organisasi Gambar 1-6 digunakan pada komputer mini selama bertahun-tahun dan juga pada
PC IBM asli. Namun, karena prosesor dan memori menjadi lebih cepat, kemampuan
dari satu bus (dan tentu saja bus IBM PC) untuk menangani semua lalu lintas tegang
ke titik putus. Sesuatu harus diberikan. Akibatnya, bus tambahan adalah
ditambahkan, baik untuk perangkat I/O yang lebih cepat dan untuk lalu lintas CPU-ke-memori. Sebagai konsekuensi dari evolusi ini, sistem x86 besar saat ini terlihat seperti Gambar 1-12

![image](https://user-images.githubusercontent.com/112523858/189534270-e2809931-886d-4439-be54-f6ce21648bac.png)

Gambar 1-12. Struktur sistem x86 besar.

Sistem ini memiliki banyak bus (misalnya, cache, memori, PCIe, PCI, USB, SATA, dan DMI), masing-masing dengan kecepatan transfer dan fungsi yang berbeda. Sistem operasi harus waspadai semuanya untuk konfigurasi dan manajemen. Bus utama adalah Bus PCIe (Peripheral Component Interconnect Express).

Bus PCIe ditemukan oleh Intel sebagai penerus bus PCI yang lebih tua, yang pada gilirannya merupakan pengganti ISA asli (Arsitektur Standar Industri) bis. Mampu mentransfer puluhan gigabit per detik, PCIe jauh lebih cepat daripada para pendahulunya. Sifatnya juga sangat berbeda. Hingga pembuatannya pada tahun 2004, sebagian besar bus paralel dan dibagi. Arsitektur bus bersama berarti bahwa beberapa perangkat menggunakan kabel yang sama untuk mentransfer data. Jadi, ketika beberapa perangkat memiliki data untuk send, Anda memerlukan seorang arbiter untuk menentukan siapa yang dapat menggunakan bus. Sebaliknya, PCIe memanfaatkan koneksi point-to-point khusus. Arsitektur bus paralel sebagai digunakan dalam PCI tradisional berarti Anda mengirim setiap kata data melalui beberapa kabel.

Misalnya, dalam bus PCI biasa, satu nomor 32-bit dikirim melalui 32 paralel kabel. Berbeda dengan ini, PCIe menggunakan arsitektur bus serial dan mengirimkan semua bit dalam pesan melalui satu koneksi, yang dikenal sebagai jalur, seperti jaringan paket. Ini jauh lebih sederhana, karena Anda tidak harus memastikan bahwa semua 32 bit tiba di tempat tujuan pada waktu yang sama. Paralelisme masih digunakan, karena Anda dapat memiliki beberapa jalur secara paralel. Misalnya, kami dapat menggunakan 32 jalur untuk membawa 32 pesan secara paralel. Seperti kecepatan perangkat periferal seperti kartu jaringan dan adapter grafis meningkat pesat, standar PCIe ditingkatkan setiap 3-5 tahun.

Misalnya, 16 jalur PCIe 2.0 menawarkan 64 gigabit per detik. Memutakhirkan ke PCIe 3.0 akan memberi Anda kecepatan dua kali lipat dan PCIe 4.0 akan menggandakannya lagi. Sementara itu, kami masih memiliki banyak perangkat lama untuk standar PCI yang lebih lama. Sebagai kita lihat pada Gambar 1-12, perangkat ini terhubung ke prosesor hub yang terpisah. Di masa depan, ketika kita menganggap PCI tidak lagi hanya tua, tetapi kuno, itu mungkin bahwa semua perangkat PCI akan dilampirkan ke hub lain yang pada gilirannya menghubungkannya ke hub utama, membuat pohon bus.

Dalam konfigurasi ini, CPU berbicara ke memori melalui bus DDR3 cepat, ke perangkat grafis eksternal melalui PCIe dan ke semua perangkat lain melalui hub melalui DMI. (Antarmuka Media Langsung) bus. Hub pada gilirannya menghubungkan semua perangkat lain, menggunakan Universal Serial Bus untuk berbicara dengan perangkat USB, bus SATA untuk berinteraksi dengan hard disk dan drive DVD, dan PCIe untuk mentransfer frame Ethernet. Kami telah menyebutkan perangkat PCI lama yang menggunakan bus PCI tradisional. Selain itu, masing-masing inti memiliki cache khusus dan cache yang jauh lebih besar yang dibagi di antara mereka. Masing-masing cache ini memperkenalkan bus lain.

USB (Universal Serial Bus) diciptakan untuk menghubungkan semua perangkat I/O yang lambat, seperti keyboard dan mouse, ke komputer. Namun, memanggil perangkat USB 3.0 modern yang berdengung pada 5 Gbps "lambat" mungkin tidak datang secara alami untuk generasi yang tumbuh dengan ISA 8-Mbps sebagai bus utama di PC IBM pertama. USB menggunakan konektor kecil dengan empat hingga sebelas kabel (tergantung versinya), beberapa di antaranya memasok daya listrik ke perangkat USB atau terhubung ke ground. USB adalah bus terpusat di mana perangkat root melakukan polling semua perangkat I/O setiap 1 msec untuk melihat apakah mereka memiliki lalu lintas. USB 1.0 dapat menangani beban agregat 12 Mbps, USB 2.0 meningkatkan kecepatan menjadi 480 Mbps, dan USB 3.0 mencapai tidak kurang dari 5 Gbps. Perangkat USB apa pun dapat dihubungkan ke komputer dan akan segera berfungsi, tanpa memerlukan reboot, sesuatu yang diperlukan perangkat pra-USB, banyak untuk kekhawatiran generasi pengguna frustrasi.

Bus SCSI (Small Computer System Interface) adalah bus berkinerja tinggi ditujukan untuk disk cepat, pemindai, dan perangkat lain yang membutuhkan lebar pita yang cukup besar. Saat ini, kami menemukan mereka sebagian besar di server dan workstation. Mereka bisa lari hingga 640 MB/detik. Untuk bekerja di lingkungan seperti Gambar 1-12, sistem operasi memiliki untuk mengetahui perangkat periferal apa yang terhubung ke komputer dan mengkonfigurasi mereka. Persyaratan ini mendorong Intel dan Microsoft untuk merancang sistem PC yang disebut plug dan bermain, berdasarkan konsep serupa yang pertama kali diterapkan di Apple Macintosh.

Sebelum plug and play, setiap kartu I/O memiliki tingkat permintaan interupsi tetap dan gaun iklan tetap untuk register I/O-nya. Misalnya, keyboard interupsi 1 dan gunakan Alamat I/O 0x60 hingga 0x64, pengontrol floppy disk diinterupsi 6 dan menggunakan I/O alamat 0x3F0 hingga 0x3F7, dan printer diinterupsi 7 dan menggunakan alamat I/O 0x378 hingga 0x37A, dan seterusnya. Sejauh ini bagus. Masalah datang ketika pengguna membeli kartu suara dan kartu modem dan keduanya kebetulan menggunakan, katakanlah, interupsi 4. Mereka akan konflik dan tidak akan bekerja sama. Solusinya adalah dengan memasukkan sakelar atau jumper DIP setiap kartu I/O dan menginstruksikan pengguna untuk menyetelnya untuk memilih tingkat interupsi dan alamat perangkat I/O yang tidak bertentangan dengan yang lain di sistem pengguna.

Remaja yang mengabdikan hidup mereka untuk kerumitan perangkat keras PC bisa terkadang melakukan ini tanpa membuat kesalahan. Sayangnya, tidak ada orang lain yang bisa, menyebabkan kekacauan. Apa yang dilakukan plug and play adalah membuat sistem secara otomatis mengumpulkan informasi tentang perangkat I/O, menetapkan tingkat interupsi dan alamat I/O secara terpusat, dan kemudian beri tahu setiap kartu berapa nomornya. Pekerjaan ini terkait erat dengan booting komputer, jadi mari kita lihat itu. Hal ini tidak sepenuhnya sepele.

### 1.3.6 Mem-boot Komputer

Secara singkat, proses booting adalah sebagai berikut. Setiap PC berisi papan induk (sebelumnya disebut motherboard sebelum kebenaran politik menghantam industri komputer). Di papan induk adalah program yang disebut sistem BIOS (Basic Input Out put System). BIOS berisi perangkat lunak I/O tingkat rendah, termasuk prosedur untuk membaca keyboard, menulis ke layar, dan melakukan disk I/O, antara lain. Sekarang ada, itu disimpan dalam flash RAM, yang nonvolatile tetapi dapat diperbarui oleh sistem operasi ketika bug ditemukan di BIOS.

Ketika komputer di-boot, BIOS dimulai. Ini pertama kali memeriksa untuk melihat caranya banyak RAM yang terpasang dan apakah keyboard dan perangkat dasar lainnya macet dan merespons dengan benar. Ini dimulai dengan memindai bus PCIe dan PCI untuk mendeteksi semua perangkat yang terpasang padanya. Jika perangkat yang ada berbeda dari ketika sistem terakhir kali di-boot, perangkat baru dikonfigurasi.

BIOS kemudian menentukan perangkat boot dengan mencoba daftar perangkat yang disimpan di memori CMOS. Pengguna dapat mengubah daftar ini dengan memasukkan konfigurasi BIOS program setelah boot. Biasanya, upaya dilakukan untuk boot dari CD-ROM (atau terkadang USB), jika ada. Jika gagal, sistem melakukan boot dari harddisk. Sektor pertama dari perangkat boot dibaca ke dalam memori dan dieksekusi. Sektor ini berisi program yang biasanya memeriksa tabel partisi di akhir sektor boot untuk menentukan partisi mana yang aktif. Kemudian boot sekunder loader dibaca dari partisi itu. Loader ini membaca di sistem operasi dari partisi aktif dan memulainya.

Sistem operasi kemudian menanyakan BIOS untuk mendapatkan informasi konfigurasi. Untuk setiap perangkat, ia akan memeriksa apakah ia memiliki driver perangkat. Jika tidak, ia bertanya pengguna untuk memasukkan CD-ROM yang berisi driver (disediakan oleh pabrik pembuat perangkat) atau untuk mengunduhnya dari Internet. Setelah memiliki semua driver perangkat, sistem operasi memuatnya ke dalam kernel. Kemudian menginisialisasi tabelnya, membuat proses latar belakang apa pun yang diperlukan, dan memulai program login atau GUI.

## 1.4 SISTEM OPERASI Z00

Sistem operasi telah ada selama lebih dari setengah abad. Selama ini Saat ini, cukup beragam yang telah dikembangkan, tidak semuanya dikenal luas. Pada bagian ini kita akan secara singkat menyentuh sembilan di antaranya. Kami akan kembali ke beberapa jenis sistem yang berbeda ini nanti dalam buku ini.

### 1.4.1 Sistem Operasi Mainframe

Di kelas atas adalah sistem operasi untuk mainframe, yang berukuran ruangan itu komputer masih ditemukan di pusat data perusahaan besar. Komputer ini berbeda dari komputer pribadi dalam hal kapasitas I/O mereka. Sebuah mainframe dengan 1000 disk dan jutaan gigabyte data tidak biasa; komputer pribadi dengan ini spesifikasi akan membuat iri teman-temannya. Mainframe juga membuat sesuatu yang kembali sebagai server Web kelas atas, server untuk elektronik skala besar situs perdagangan, dan server untuk transaksi bisnis-ke-bisnis. 

Sistem operasi untuk mainframe sangat berorientasi pada pemrosesan banyak pekerjaan sekaligus, yang sebagian besar membutuhkan jumlah I/O yang luar biasa. Mereka biasanya menawarkan tiga jenis layanan: batch, pemrosesan transaksi, dan pembagian waktu. Sebuah sistem batch adalah salah satu yang memproses pekerjaan rutin tanpa kehadiran pengguna interaktif. Pemrosesan klaim di perusahaan asuransi atau pelaporan penjualan untuk rantai toko biasanya dilakukan dalam mode batch. Sistem pemrosesan transaksi menangani sejumlah besar permintaan kecil, misalnya, pemrosesan cek di bank atau reservasi maskapai penerbangan. Setiap unit kerja kecil, tetapi sistem harus menangani ratusan atau ribuan pasir per detik. Sistem pembagian waktu memungkinkan banyak pengguna jarak jauh untuk menjalankan pekerjaan di komputer sekaligus, seperti query database besar. Fungsi-fungsi ini erat terkait; sistem operasi mainframe sering melakukan semuanya. Sebuah contoh sistem operasi mainframe adalah OS/390, turunan dari OS/360. Namun, sistem operasi kerangka utama secara bertahap digantikan oleh varian UNIX seperti: Linux.

### 1.4.2 Sistem Operasi Server

Satu tingkat ke bawah adalah sistem operasi server. Mereka berjalan di server, yang adalah komputer pribadi yang sangat besar, workstation, atau bahkan mainframe. Mereka melayani banyak pengguna sekaligus melalui jaringan dan memungkinkan pengguna untuk berbagi perangkat keras dan sumber daya perangkat lunak. Server dapat menyediakan layanan cetak, layanan file, atau Web melayani. Penyedia internet menjalankan banyak mesin server untuk mendukung pelanggan mereka dan Situs Web menggunakan server untuk menyimpan halaman Web dan menangani permintaan yang masuk. Sistem operasi server yang umum adalah Solaris, FreeBSD, Linux dan Windows Server 201x.

### 1.4.3 Sistem Operasi Multiprosesor

Cara yang semakin umum untuk mendapatkan kekuatan komputasi liga utama adalah dengan menghubungkan beberapa CPU ke dalam satu sistem. Tergantung pada bagaimana tepatnya mereka terhubung dan apa yang dibagi, sistem ini disebut komputer paralel, multi komputer, atau multiprosesor. Mereka membutuhkan sistem operasi khusus, tetapi seringkali ini adalah variasi pada sistem operasi server, dengan fitur khusus untuk komunikasi, konektivitas, dan konsistensi.

Dengan munculnya chip multicore baru-baru ini untuk komputer pribadi, bahkan sistem operasi desktop dan notebook konvensional mulai dihadapi di multiprosesor skala kecil dan jumlah core kemungkinan akan bertambah waktu. Untungnya, sedikit yang diketahui tentang sistem operasi multiprosesor dari tahun penelitian sebelumnya, jadi menggunakan pengetahuan ini dalam sistem multicore harus tidak keras. Bagian yang sulit adalah aplikasi yang memanfaatkan semua kekuatan komputasi ini. Banyak sistem operasi populer, termasuk Windows dan Linux, dijalankan pada multiprosesor

### 1.4.4 Sistem Operasi Komputer Pribadi

Kategori berikutnya adalah sistem operasi komputer pribadi. Yang modern semua mendukung multiprogramming, seringkali dengan lusinan program yang dijalankan saat boot. Tugas mereka adalah memberikan dukungan yang baik kepada satu pengguna. Mereka banyak digunakan untuk pengolah kata, spreadsheet, game, dan akses Internet. Contoh umum adalah Linux, FreeBSD, Windows 7, Windows 8, dan Apple OS X. Komputer pribadi sistem operasi begitu dikenal luas sehingga mungkin sedikit pengenalan yang diperlukan. Bahkan, banyak orang bahkan tidak menyadari bahwa ada jenis lain.

### 1.4.5 Sistem Operasi Komputer Genggam

Melanjutkan ke sistem yang lebih kecil dan lebih kecil, kami datang ke tablet, smartphone dan komputer genggam lainnya. Komputer genggam, awalnya dikenal sebagai PDA (Personal Digital Assistant), adalah komputer kecil yang dapat dipegang di tangan Anda selama operasi. Smartphone dan tablet adalah yang paling terkenal contoh. Seperti yang telah kita lihat, pasar ini saat ini didominasi oleh Android Google dan iOS Apple, tetapi mereka memiliki banyak pesaing. Sebagian besar dari ini
perangkat membanggakan CPU multicore, GPS, kamera dan sensor lainnya, jumlah yang berlebihan
memori, dan sistem operasi yang canggih. Selain itu, semuanya memiliki lebih banyak
aplikasi pihak ketiga (''aplikasi'') daripada Anda dapat menggoyangkan tongkat (USB).

### 1.4.6 Sistem Operasi Tertanam

Sistem tertanam berjalan pada komputer yang mengontrol perangkat yang umumnya tidak dianggap sebagai komputer dan yang tidak menerima perangkat lunak yang diinstal pengguna. Contoh umum adalah oven microwave, perangkat TV, mobil, perekam DVD, tradisional ponsel, dan pemutar MP3. Properti utama yang membedakan sistem tertanam dari perangkat genggam adalah kepastian bahwa tidak ada perangkat lunak yang tidak dapat dipercaya yang akan berjalan di atasnya.

Anda tidak dapat mengunduh aplikasi baru ke oven microwave Anda—semua perangkat lunak ada di ROM. Ini berarti bahwa tidak ada kebutuhan untuk perlindungan antara aplikasi, mengarah pada penyederhanaan desain. Sistem seperti Linux Tertanam, QNX dan VxWorks populer di domain ini.

### 1.4.7 Sistem Operasi Sensor-Node

Jaringan node sensor kecil sedang digunakan untuk berbagai tujuan. Node ini adalah komputer kecil yang berkomunikasi satu sama lain dan dengan basis stasiun menggunakan komunikasi nirkabel. Jaringan sensor digunakan untuk melindungi perimeter bangunan, menjaga perbatasan negara, mendeteksi kebakaran di hutan, mengukur suhu dan curah hujan untuk prakiraan cuaca, dapatkan informasi tentanggerakan musuh di medan perang, dan banyak lagi. 

Sensornya adalah komputer kecil bertenaga baterai dengan radio built-in. Mereka memiliki daya terbatas dan harus bekerja dalam waktu lama tanpa pengawasan di luar ruangan, sering dalam kondisi lingkungan yang keras. Jaringan harus kuat cukup untuk mentolerir kegagalan node individu, yang terjadi dengan terus meningkat frekuensi saat baterai mulai habis.

Setiap node sensor adalah komputer nyata, dengan CPU, RAM, ROM, dan satu atau lebih banyak sensor lingkungan. Ini menjalankan sistem operasi kecil, tapi nyata, biasanya satu yang digerakkan oleh peristiwa, merespons peristiwa eksternal atau membuat periode pengukuran berdasarkan jam internal. Sistem operasi harus kecil dan sederhana karena node memiliki sedikit RAM dan masa pakai baterai adalah masalah besar. Juga, sebagai dengan sistem tertanam, semua program dimuat terlebih dahulu; pengguna tidak tiba-tiba memulai program yang mereka unduh dari Internet, yang membuat desainnya jauh lebih sederhana. TinyOS adalah sistem operasi terkenal untuk node sensor.

### 1.4.8 Sistem Operasi Waktu Nyata

Jenis lain dari sistem operasi adalah sistem real-time. Sistem-sistem ini adalah
ditandai dengan memiliki waktu sebagai parameter kunci. Misalnya, dalam sistem kontrol proses industri, komputer waktu nyata harus mengumpulkan data tentang produksi memproses dan menggunakannya untuk mengontrol mesin di pabrik. Seringkali ada tenggat waktu yang sulit yang harus dipenuhi. Misalnya, jika sebuah mobil bergerak di jalur perakitan, pasti tindakan harus dilakukan pada saat-saat tertentu. Jika, misalnya, robot pengelasan las terlalu dini atau terlambat, mobil akan hancur. Jika tindakan itu mutlak harus terjadi pada saat tertentu (atau dalam rentang tertentu), kami mengalami kesulitan waktu nyata sistem. Banyak dari ini ditemukan dalam kontrol proses industri, avionik, militer, dan area aplikasi serupa. Sistem ini harus memberikan jaminan mutlak bahwa tindakan tertentu akan terjadi pada waktu tertentu.

Sistem waktu-nyata yang lembut, adalah sistem di mana kadang-kadang melewatkan tenggat waktu, sementara tidak diinginkan, dapat diterima dan tidak menyebabkan kerusakan permanen. Digital sistem audio atau multimedia termasuk dalam kategori ini. Ponsel cerdas juga merupakan sistem waktu nyata yang lembut. Karena memenuhi tenggat waktu sangat penting dalam sistem waktu nyata (keras), terkadang sistem operasi hanyalah perpustakaan yang terhubung dengan program aplikasi, dengan semuanya digabungkan dengan erat dan tidak ada perlindungan di antara bagian-bagian sistem. Contoh sistem real-time jenis ini adalah eCos.

Kategori perangkat genggam, sistem tertanam, dan sistem waktu nyata tumpang tindih sangat. Hampir semuanya memiliki setidaknya beberapa aspek soft real-time. Sistem embedded dan real-time hanya menjalankan perangkat lunak yang dipasang oleh perancang sistem; pengguna tidak dapat menambahkan perangkat lunak mereka sendiri, yang membuat perlindungan lebih mudah. Perangkat genggam dan sistem tertanam ditujukan untuk konsumen, sedangkan sistem waktu nyata adalah lebih untuk penggunaan industri. Namun demikian, mereka memiliki kesamaan dalam jumlah tertentu.

### 1.4.9 Sistem Operasi Kartu Cerdas

Sistem operasi terkecil berjalan pada kartu pintar, yang berukuran kartu kredit perangkat yang berisi chip CPU. Mereka memiliki kekuatan pemrosesan dan keterbatasan memori yang sangat parah. Beberapa didukung oleh kontak di pembaca di mana mereka berada dimasukkan, tetapi kartu pintar tanpa kontak ditenagai secara induktif, yang sangat membatasi apa yang bisa mereka lakukan. Beberapa dari mereka hanya dapat menangani satu fungsi, seperti pembayaran elektronik, tetapi yang lain dapat menangani beberapa fungsi. Seringkali ini adalah sistem kepemilikan.

Beberapa kartu pintar berorientasi pada Java. Ini berarti bahwa ROM pada smart kartu memegang juru bahasa untuk Java Virtual Machine (JVM). Applet Java (kecil program) diunduh ke kartu dan ditafsirkan oleh penerjemah JVM.

Beberapa dari kartu ini dapat menangani beberapa applet Java secara bersamaan, yang mengarah ke multiprogramming dan kebutuhan untuk menjadwalkannya. Manajemen dan perlindungan sumber daya juga menjadi masalah ketika dua atau lebih applet hadir secara bersamaan waktu. Masalah ini harus ditangani oleh operasi (biasanya sangat primitif). sistem yang ada pada kartu.

## 1.5 KONSEP SISTEM OPERASI

Sebagian besar sistem operasi menyediakan konsep dasar dan abstraksi tertentu seperti: proses, ruang alamat, dan file yang penting untuk memahaminya. Dalam bagian berikut, kita akan melihat beberapa konsep dasar ini secara singkat, seperti: sebuah pengantar. Kami akan kembali ke masing-masing dengan sangat rinci nanti dalam hal ini buku. Untuk mengilustrasikan konsep-konsep ini, dari waktu ke waktu, kami akan menggunakan contoh-contoh, yang umumnya diambil dari UNIX. Contoh serupa biasanya ada di sistem lain juga, namun, dan kami akan mempelajari beberapa di antaranya nanti

### 1.5.1 Proses

Konsep kunci dalam semua sistem operasi adalah proses. Sebuah proses pada dasarnya adalah program dalam eksekusi. Terkait dengan setiap proses adalah ruang alamatnya, daftar lokasi memori dari 0 hingga maksimum, yang dapat dibaca dan ditulis oleh proses. Ruang alamat berisi program yang dapat dieksekusi, data program, dan tumpukan. Juga terkait dengan setiap proses adalah satu set sumber daya, biasanya termasuk: register (termasuk penghitung program dan penunjuk tumpukan), daftar file yang terbuka, alarm yang tidak aktif, daftar proses terkait, dan semua informasi lain yang diperlukan untuk menjalankan program. Sebuah proses pada dasarnya adalah wadah yang menampung semua informasi yang dibutuhkan untuk menjalankan sebuah program.

Kami akan kembali ke konsep proses secara lebih rinci di Bab. 2. Untuk saat ini, cara termudah untuk mendapatkan perasaan intuitif yang baik untuk suatu proses adalah dengan berpikir tentang sistem multiprogramming. Pengguna mungkin telah memulai program pengeditan video dan menginstruksikannya untuk mengonversi video berdurasi satu jam ke format tertentu (sesuatu) yang bisa memakan waktu berjam-jam) dan kemudian pergi menjelajahi Web. Sementara itu, latar belakang proses yang bangun secara berkala untuk memeriksa email masuk mungkin sudah dimulai berlari. Jadi kami memiliki (setidaknya) tiga proses aktif: editor video, Web browser, dan penerima email. Secara berkala, sistem operasi memutuskan untuk berhenti menjalankan satu proses dan mulai menjalankan yang lain, mungkin karena yang pertama memiliki menghabiskan lebih dari porsi waktu CPU dalam satu atau dua detik terakhir.

Ketika sebuah proses dihentikan sementara seperti ini, nanti harus di-restart dalam keadaan yang sama persis ketika dihentikan. Ini berarti bahwa semua informasi tentang proses harus secara eksplisit disimpan di suatu tempat selama penangguhan. Untuk misalnya, proses mungkin memiliki beberapa file yang terbuka untuk dibaca sekaligus. Terkait dengan masing-masing file ini adalah penunjuk yang memberikan posisi saat ini (yaitu, jumlah byte atau record yang akan dibaca selanjutnya). Ketika sebuah proses dihentikan sementara, semua pointer ini harus disimpan sehingga panggilan baca yang dijalankan setelah proses dimulai ulang akan membaca data yang benar. Di banyak sistem operasi, semua informasi tentang setiap proses, selain isi ruang alamatnya sendiri, disimpan dalam tabel sistem operasi yang disebut tabel proses, yang merupakan larik struktur, satu untuk setiap proses yang ada saat ini.

Dengan demikian, proses (ditangguhkan) terdiri dari ruang alamatnya, biasanya disebut gambar inti (untuk menghormati memori inti magnetik yang digunakan di masa lalu), dan entri tabel proses, yang berisi isi registernya dan banyak lainnya item yang diperlukan untuk memulai kembali proses nanti.

Panggilan sistem manajemen proses utama adalah panggilan yang berhubungan dengan penciptaan dan penghentian proses. Pertimbangkan contoh tipikal. Sebuah proses yang disebut juru bahasa perintah atau shell membaca perintah dari terminal. Pengguna baru saja mengetikkan perintah yang meminta program dikompilasi. Shell sekarang harus membuat proses baru yang akan menjalankan compiler. Ketika proses itu telah selesai, kompilasi, ia mengeksekusi panggilan sistem untuk mengakhiri dirinya sendiri.

Jika suatu proses dapat membuat satu atau lebih proses lain (disebut sebagai proses anak) dan proses ini pada gilirannya dapat membuat proses anak, kita dengan cepat sampai pada struktur pohon proses Gambar 1-13. Proses terkait yang bekerja sama untuk menyelesaikan beberapa pekerjaan sering perlu berkomunikasi satu sama lain dan menyinkronkan kegiatan mereka. Komunikasi ini disebut komunikasi antarproses, dan akan dibahas secara rinci dalam Bab. 2.

![Gambar1-13](https://user-images.githubusercontent.com/112523858/189548448-6d8f792e-aef5-43a7-94d7-20fe38a69918.JPG)

Gambar 1-13. Sebuah pohon proses. Proses A membuat dua proses anak, B dan C. Proses B membuat tiga proses anak, D, E, dan F.

Panggilan sistem proses lain tersedia untuk meminta lebih banyak memori (atau melepaskan memori yang tidak digunakan), tunggu proses anak untuk mengakhiri, dan overlay programnya dengan yang berbeda. Terkadang, ada kebutuhan untuk menyampaikan informasi ke proses yang sedang berjalan yaitu tidak duduk-duduk menunggu informasi ini. Misalnya, sebuah proses yang berkomunikasi dengan proses lain di komputer yang berbeda melakukannya dengan mengirimkan pesan ke proses jarak jauh melalui jaringan komputer. Untuk menjaga dari kemungkinan pesan atau balasannya hilang, pengirim dapat meminta agar sistem operasinya sendiri memberitahukannya setelah beberapa detik tertentu, sehingga dapat mengirim ulang. pesan jika belum ada pengakuan yang diterima. Setelah mengatur timer ini, program dapat terus melakukan pekerjaan lain.

Ketika jumlah detik yang ditentukan telah berlalu, sistem operasi mengirim sinyal alarm untuk proses. Sinyal menyebabkan proses untuk sementara menangguhkan apa pun yang dilakukannya, menyimpan registernya di tumpukan, dan mulai menjalankan prosedur penanganan sinyal khusus, misalnya, untuk mengirim ulang pesan yang mungkin hilang.

Ketika jumlah detik yang ditentukan telah berlalu, sistem operasi mengirim sinyal alarm untuk proses. Sinyal menyebabkan proses untuk sementara menangguhkan apa pun yang dilakukannya, menyimpan registernya di tumpukan, dan mulai menjalankan prosedur penanganan sinyal khusus, misalnya, untuk mengirim ulang pesan yang mungkin hilang. Ketika penangan sinyal selesai, proses yang berjalan dimulai ulang dalam keadaan itu tepat sebelum sinyal. Sinyal adalah analog perangkat lunak dari gangguan perangkat keras dan dapat dihasilkan oleh berbagai penyebab selain penghitung waktu yang kedaluwarsa.

Banyak jebakan yang terdeteksi oleh perangkat keras, seperti mengeksekusi instruksi ilegal atau menggunakan alamat yang tidak valid, juga diubah menjadi sinyal untuk proses yang bersalah. Setiap orang yang berwenang untuk menggunakan sistem diberi UID (User IDentification) oleh administrator sistem. Setiap proses yang dimulai memiliki UID orang tersebut siapa yang memulainya. Proses anak memiliki UID yang sama dengan induknya. Pengguna dapat menjadi anggota grup, yang masing-masing memiliki GID (Group IDentification).

Satu UID, disebut superuser (di UNIX), atau Administrator (di Windows), memiliki kekuatan khusus dan dapat mengesampingkan banyak aturan perlindungan. Di kios besar, hanya administrator sistem yang tahu kata sandi yang dibutuhkan untuk menjadi pengguna super, tetapi banyak dari pengguna biasa (terutama siswa) mencurahkan banyak hal upaya mencari kelemahan dalam sistem yang memungkinkan mereka menjadi superuser tanpa kata sandi.

Kami akan mempelajari proses dan komunikasi antar proses di Bab. 2.

### 1.5.2 Ruang Alamat

Setiap komputer memiliki beberapa memori utama yang digunakan untuk menyimpan pro gram. Dalam sistem operasi yang sangat sederhana, hanya satu program dalam satu waktu yang ada di memori. Untuk menjalankan program kedua, yang pertama harus dihapus dan yang kedua ditempatkan dalam memori.

Sistem operasi yang lebih canggih memungkinkan beberapa program berada di memori pada saat yang bersamaan. Agar mereka tidak saling mengganggu (dan dengan sistem operasi), diperlukan semacam mekanisme proteksi. Meskipun mekanisme ini harus ada di perangkat keras, mekanisme ini dikendalikan oleh sistem operasi. Sudut pandang di atas berkaitan dengan pengelolaan dan perlindungan memori utama komputer. Masalah terkait memori yang berbeda, tetapi sama pentingnya adalah mengelola ruang alamat proses. Biasanya, setiap proses memiliki beberapa set alamat yang dapat digunakan, biasanya berjalan dari 0 hingga beberapa maksimum. Dalam kasus yang paling sederhana, jumlah maksimum ruang alamat yang dimiliki suatu proses kurang dari memori utama. Dengan cara ini, suatu proses dapat mengisi ruang alamatnya dan akan ada cukup ruang di memori utama untuk menampung semuanya.

Namun, pada banyak komputer alamat 32 atau 64 bit, memberikan alamat ruang 232 atau 264 byte, masing-masing. Apa yang terjadi jika suatu proses memiliki lebih banyak alamat ruang dari komputer memiliki memori utama dan proses ingin menggunakan semuanya? Di komputer pertama, proses seperti itu hanya kurang beruntung. Saat ini, ada teknik yang disebut memori virtual yang dipimpin, seperti yang disebutkan sebelumnya, di mana sistem operasi menyimpan sebagian dari ruang alamat di memori utama dan sebagian lagi di disk dan antar-jemput potongan bolak-balik di antara mereka sesuai kebutuhan. Intinya, sistem operasi menciptakan abstraksi ruang alamat sebagai kumpulan alamat yang mungkin dilakukan oleh suatu proses referensi. Ruang alamat dipisahkan dari memori fisik mesin dan mungkin lebih besar atau lebih kecil dari memori fisik. Pengelolaan ruang iklan dan memori fisik merupakan bagian penting dari apa yang beroperasi sistem tidak, jadi semua Chap. 3 dikhususkan untuk topik ini

### 1.5.3 File

Konsep kunci lain yang didukung oleh hampir semua sistem operasi adalah file sistem. Seperti disebutkan sebelumnya, fungsi utama dari sistem operasi adalah untuk menyembunyikan kekhasan disk dan perangkat I/O lainnya dan memberi programmer model abstrak yang bagus dan bersih dari file yang tidak bergantung pada perangkat. Panggilan sistem jelas diperlukan untuk membuat file, menghapus file, membaca file, dan menulis file. Sebelum file dapat dibaca, itu harus ditempatkan di disk dan dibuka, dan setelah dibaca itu harus ditutup, jadi panggilan disediakan untuk melakukan hal-hal ini.

Untuk menyediakan tempat menyimpan file, sebagian besar sistem operasi PC memiliki konsep direktori sebagai cara mengelompokkan file bersama-sama. Seorang siswa, misalnya, mungkin memiliki satu direktori untuk setiap kursus yang dia ambil (untuk program yang diperlukan untuk itu saja), direktori lain untuk surat elektroniknya, dan masih direktori lain untuknya Halaman beranda World Wide Web. Panggilan sistem kemudian diperlukan untuk membuat dan menghapus direktori. Panggilan juga disediakan untuk meletakkan file yang ada di direktori dan untuk memindahkan file dari direktori. Entri direktori dapat berupa file atau direktori lainnya. Model ini juga memunculkan hierarki — sistem file — seperti yang ditunjukkan pada Gambar 1-14

![image](https://user-images.githubusercontent.com/112523858/189548625-91caec4e-04b6-4c5f-b18e-2d049a9fd900.png)

Gambar 1-14. Sistem file untuk departemen universitas.

Proses dan hierarki file keduanya diatur sebagai pohon, tetapi kesamaannya berhenti di sana. Hirarki proses biasanya tidak terlalu dalam (lebih dari tiga level adalah tidak biasa), sedangkan hierarki file biasanya empat, lima, atau bahkan lebih banyak level dalam. Hirarki proses biasanya berumur pendek, umumnya paling banyak menit, sedangkan hierarki direktori mungkin ada selama bertahun-tahun. Kepemilikan dan perlindungan juga  berbeda untuk proses dan file. Biasanya, hanya proses induk yang dapat mengontrol atau bahkan mengakses proses anak, tetapi mekanisme hampir selalu ada untuk memungkinkan file dan direktori dibaca oleh kelompok yang lebih luas daripada hanya pemiliknya.

Setiap file dalam hierarki direktori dapat ditentukan dengan memberikan jalurnya nama dari bagian atas hierarki direktori, direktori root. Mutlak seperti itu nama path terdiri dari daftar direktori yang harus dilalui dari direktori root untuk sampai ke file, dengan garis miring memisahkan komponen. Pada Gambar 1-14, path untuk file CS101 adalah /Faculty/Prof.Brown/Courses/CS101. Garis miring di depan menunjukkan bahwa jalurnya mutlak, yaitu, dimulai dari direktori root. Sebagai tambahan, di Windows, karakter garis miring terbalik (\) digunakan sebagai pemisah, bukan garis miring (/) karakter (untuk alasan historis), sehingga jalur file yang diberikan di atas akan ditulis sebagai \Faculty\Prof.Brown\Courses\CS101. Sepanjang buku ini kita biasanya akan menggunakan konvensi UNIX untuk jalur.

Setiap saat, setiap proses memiliki direktori kerja saat ini, di mana jalur nama yang tidak diawali dengan garis miring akan dicari. Misalnya, pada Gambar 1-14, jika /Faculty/Prof.Brown adalah direktori kerja, penggunaan jalur Courses/CS101 akan menghasilkan file yang sama dengan nama path absolut yang diberikan di atas. Proses bisa ubah direktori kerja mereka dengan mengeluarkan panggilan sistem yang menentukan direktori kerja baru.

Sebelum file dapat dibaca atau ditulis, file itu harus dibuka, pada saat itu per misi diperiksa. Jika akses diizinkan, sistem mengembalikan bilangan bulat kecil disebut deskriptor file untuk digunakan dalam operasi selanjutnya. Jika aksesnya dilarang, kode kesalahan dikembalikan.

Konsep penting lainnya di UNIX adalah sistem file yang di-mount. Kebanyakan desktop komputer memiliki satu atau lebih drive optik di mana CD-ROM, DVD, dan cakram Blu ray dapat dimasukkan. Mereka hampir selalu memiliki port USB, di mana USB memory stick (benar-benar, solid state disk drive) dapat dipasang, dan beberapa komputer memiliki floppy disk atau hard disk eksternal. Untuk memberikan cara yang elegan untuk berurusan dengan media yang dapat dilepas ini UNIX memungkinkan sistem file pada disk optik untuk dilampirkan ke pohon utama. Pertimbangkan situasi Gambar 1-15(a). Sebelum gunung panggilan, sistem file root, pada hard disk, dan sistem file kedua, pada CD ROM, terpisah dan tidak terkait.

Namun, sistem file pada CD-ROM tidak dapat digunakan, karena tidak ada cara untuk menentukan nama jalur di atasnya. UNIX tidak mengizinkan nama jalur untuk diawali dengan nama atau nomor drive; itu akan menjadi jenis ketergantungan perangkat yang harus dihilangkan oleh sistem operasi. Sebagai gantinya, panggilan sistem mount memungkinkan sistem file pada CD-ROM untuk dilampirkan ke sistem file root di mana pun program menginginkannya. Pada Gambar 1-15(b) sistem file pada CD-ROM telah dipasang pada direktori b, sehingga memungkinkan akses ke file /b/x dan /b/y. Jika direktori b berisi file apa pun yang tidak akan dapat diakses saat CD-ROM mount, karena /b akan merujuk ke direktori root CD-ROM. (Tidak menjadi dapat mengakses file-file ini tidak seserius kelihatannya: sistem file hampir selalu dipasang pada direktori kosong.) Jika sistem berisi banyak hard disk, mereka semua dapat dipasang ke dalam satu pohon juga.

![image](https://user-images.githubusercontent.com/112523858/189548755-b447023b-4e2a-47a6-a71f-97d17c72c3f3.png)

Gambar 1-15. (a) Sebelum pemasangan, file pada CD-ROM tidak dapat diakses. (b) Setelah pemasangan, mereka adalah bagian dari hierarki file.

Konsep penting lainnya dalam UNIX adalah file khusus. File khusus disediakan untuk membuat perangkat I/O terlihat seperti file. Dengan begitu, mereka dapat dibaca dan ditulis menggunakan panggilan sistem yang sama seperti yang digunakan untuk membaca dan menulis file. Dua jenis file khusus yang ada: blok file khusus dan file karakter khusus. Memblokir file khusus digunakan untuk memodelkan perangkat yang terdiri dari kumpulan blok yang dapat disesuaikan secara acak, seperti disk. Dengan membuka file khusus blok dan membaca, katakanlah, blok 4, sebuah program dapat langsung mengakses blok keempat pada perangkat, tanpa berkaitan dengan struktur sistem file yang terdapat di dalamnya. Demikian pula, file khusus karakter digunakan untuk memodelkan printer, modem, dan perangkat lain yang menerima atau mengeluarkan aliran karakter. Berdasarkan konvensi, file khusus disimpan di direktori /dev. Misalnya, /dev/lp mungkin adalah printer (dulu disebut printer baris).

Fitur terakhir yang akan kita bahas dalam ikhtisar ini berkaitan dengan proses dan file: pipa. Pipe adalah semacam pseudofile yang dapat digunakan untuk menghubungkan dua proses, seperti yang ditunjukkan pada Gambar 1-16. Jika proses A dan B ingin berbicara menggunakan pipa, mereka harus mengaturnya terlebih dahulu. Ketika proses A ingin mengirim data ke proses B, ia menulis: pada pipa seolah-olah itu adalah file output. Sebenarnya, implementasi pipa adalah sangat mirip dengan file. Proses B dapat membaca data dengan membaca dari pipa seolah-olah itu adalah file input. Jadi, komunikasi antar proses di UNIX terlihat sangat mirip dengan file biasa yang membaca dan menulis. Lebih kuat lagi, satu-satunya cara proses dapat menemukan bahwa file output yang digunakan untuk menulis bukan benar-benar file, tetapi pipa, adalah dengan membuat panggilan sistem khusus. Sistem file sangat penting. Kami akan memiliki lebih banyak untuk dikatakan tentang mereka di Bab. 4 dan juga di Bab. 10 dan 11

![image](https://user-images.githubusercontent.com/112523858/189548799-ece59596-f6d6-457f-8ed3-7d573b2c1744.png)
konyu
### 1.5.4 Masukan/Keluaran

Semua komputer memiliki perangkat fisik untuk memperoleh input dan menghasilkan output. Lagi pula, apa gunanya komputer jika pengguna tidak tahu apa yang harus dilakukan dan tidak bisa mendapatkan hasil setelah melakukan pekerjaan yang diminta? Banyak jenis masukan dan perangkat output ada, termasuk keyboard, monitor, printer, dan sebagainya. Dia hingga sistem operasi untuk mengelola perangkat ini.

Akibatnya, setiap sistem operasi memiliki subsistem I/O untuk mengelolanya perangkat I/O. Beberapa perangkat lunak I/O tidak bergantung pada perangkat, yaitu berlaku untuk banyak atau semua perangkat I/O sama baiknya. Bagian lain dari itu, seperti driver perangkat, adalah khusus untuk perangkat I/O tertentu. Dalam Bab. 5 kita akan melihat perangkat lunak I/O.

### 1.5.5 Perlindungan

Komputer berisi sejumlah besar informasi yang sering ingin dilindungi dan dijaga kerahasiaannya oleh pengguna. Informasi ini mungkin termasuk email, rencana bisnis, pajak kembali, dan banyak lagi. Terserah sistem operasi untuk mengelola keamanan sistem sehingga file, misalnya, hanya dapat diakses oleh pengguna yang berwenang. Sebagai contoh sederhana, hanya untuk mendapatkan gambaran tentang cara kerja keamanan, pertimbangkan UNIX. File di UNIX dilindungi dengan memberikan masing-masing kode proteksi biner 9-bit. Kode perlindungan terdiri dari tiga bidang 3-bit, satu untuk pemilik, satu untuk anggota lain dari grup pemilik (pengguna dibagi menjadi beberapa grup oleh administrator sistem), dan satu untuk semua orang. Setiap bidang memiliki sedikit untuk akses baca, sedikit untuk akses tulis, dan sedikit untuk akses eksekusi. 3 bit ini dikenal sebagai rwx bit. Misalnya, kode perlindungan rwxr-x--x berarti pemiliknya dapat membaca, menulis, atau mengeksekusi file, anggota grup lain dapat membaca atau mengeksekusi (tetapi tidak menulis) file, dan semua orang dapat mengeksekusi (tetapi tidak membaca atau menulis) file. Untuk sebuah direktori, x menunjukkan izin pencarian. Tanda hubung berarti bahwa per misi yang sesuai tidak ada.

Selain perlindungan file, ada banyak masalah keamanan lainnya. Melindungi sistem dari penyusup yang tidak diinginkan, baik manusia maupun bukan manusia (misalnya, virus) adalah salah satu diantara mereka. Kita akan melihat berbagai masalah keamanan di Bab. 9.

### 1.5.6 Kulitnya

Sistem operasi adalah kode yang melakukan panggilan sistem. Editor, compiler, assembler, linker, program utilitas, dan interpreter perintah jelas bukan bagian dari sistem operasi, meskipun mereka penting dan berguna. Dengan risiko agak membingungkan, di bagian ini kita akan melihat secara singkat di penerjemah perintah UNIX, shell. Meskipun bukan bagian dari sistem operasi, ia menggunakan banyak fitur sistem operasi dan dengan demikian berfungsi sebagai contoh yang baik tentang bagaimana panggilan sistem digunakan. Ini juga merupakan antarmuka utama antara pengguna yang duduk di terminalnya dan sistem operasi, kecuali pengguna tersebut menggunakan antarmuka pengguna grafis. Banyak shell yang ada, termasuk sh, csh, ksh, dan bash. Semuanya mendukung fungsionalitas yang dijelaskan di bawah, yang berasal dari shell asli (sh).

Ketika ada pengguna yang masuk, shell dimulai. Shell memiliki terminal sebagai input standar dan output standar. Ini dimulai dengan mengetik prompt, karakter seperti tanda dolar, yang memberi tahu pengguna bahwa shell sedang menunggu untuk menerima perintah. Jika pengguna sekarang mengetik

`date`

misalnya, shell membuat proses anak dan menjalankan program tanggal sebagai anak. Saat proses anak sedang berjalan, shell menunggunya untuk dihentikan. Kapan anak selesai, shell mengetik prompt lagi dan mencoba membaca input berikutnya garis.

Pengguna dapat menentukan bahwa output standar diarahkan ke file, misalnya,

date > berkas

Demikian pula, input standar dapat diarahkan, seperti pada

urutkan < file1 > file2

yang memanggil program sortir dengan input diambil dari file1 dan output dikirim ke file2. Output dari satu program dapat digunakan sebagai input untuk program lain dengan: menghubungkannya dengan pipa. Dengan demikian

cat file1 file2 file3 | sort >/dev/lp

memanggil program cat untuk menggabungkan tiga file dan mengirim output untuk diurutkan ke mengatur semua baris dalam urutan abjad. Output dari sort diarahkan ke file /dev/lp, biasanya printer.

Jika pengguna meletakkan ampersand setelah perintah, shell tidak menunggu sampai menyelesaikan. Sebaliknya itu hanya memberikan prompt segera. Akibatnya,

cat file1 file2 file3 | urutkan >/dev/lp &

memulai pengurutan sebagai pekerjaan latar belakang, memungkinkan pengguna untuk terus bekerja atau tidak sementara pengurutan sedang berlangsung. Shell memiliki sejumlah fitur menarik lainnya, yang tidak dapat kami bahas di sini. Sebagian besar buku tentang UNIX membahas cangkang agak panjang (misalnya, Kernighan dan Pike, 1984; Quigley, 2004; Robbins, 2005).

Sebagian besar komputer pribadi saat ini menggunakan GUI. Faktanya, GUI hanyalah sebuah program yang berjalan di atas sistem operasi, seperti sebuah shell. Dalam sistem Linux, ini fakta menjadi jelas karena pengguna memiliki pilihan (setidaknya) dua GUI: Gnome dan KDE atau tidak sama sekali (menggunakan jendela terminal pada X11). Di Windows, itu juga mungkin untuk mengganti desktop GUI standar (Windows Explorer) dengan yang berbeda program dengan mengubah beberapa nilai dalam registri, meskipun hanya sedikit orang yang melakukan ini.

### 1.5.7 Ontogeni Merekapitulasi Filogeni

Setelah buku Charles Darwin On the Origin of the Species diterbitkan, Ahli zoologi Jerman Ernst Haeckel menyatakan bahwa "ontogeni merekapitulasi filogeni". Dengan ini dia bermaksud bahwa perkembangan embrio (ontogeni) mengulangi (yaitu, reca pitulates) evolusi spesies (filogeni). Dengan kata lain, setelah pembuahan, telur manusia melewati tahapan menjadi ikan, babi, dan seterusnya sebelum berubah menjadi bayi manusia. Ahli biologi modern menganggap ini sebagai penyederhanaan kasar, tapi itu masih memiliki inti kebenaran di dalamnya.

Sesuatu yang samar-samar analog telah terjadi di industri komputer. Setiap spesies baru (mainframe, komputer mini, komputer pribadi, genggam, tertanam komputer, kartu pintar, dll) tampaknya melalui perkembangan yang nenek moyangnya dilakukan, baik dalam perangkat keras maupun perangkat lunak. Kita sering melupakan banyak hal yang terjadi dalam bisnis komputer dan banyak bidang lainnya didorong oleh teknologi. Alasannya orang Romawi kuno tidak memiliki mobil bukan karena mereka sangat suka berjalan kaki. Itu karena mereka tidak tahu bagaimana membuat mobil. Komputer pribadi ada bukan karena jutaan orang memiliki keinginan terpendam selama berabad-abad untuk memiliki komputer, tetapi karena sekarang mungkin untuk memproduksinya dengan murah. Kita sering lupa betapa teknologi mempengaruhi pandangan kita tentang sistem dan hal ini layak untuk direfleksikan dari waktu demi waktu.

Secara khusus, sering terjadi bahwa perubahan teknologi membuat beberapa ide usang dan dengan cepat menghilang. Namun, perubahan lain dalam teknologi bisa menghidupkannya kembali. Ini terutama benar ketika perubahan itu berkaitan dengan kinerja relatif dari berbagai bagian sistem. Misalnya, ketika CPU menjadi jauh lebih cepat daripada kenangan, cache menjadi penting untuk mempercepat memori ''lambat''. Jika teknologi memori baru suatu hari nanti membuat banyak kenangan lebih cepat dari CPU, cache akan hilang. Dan jika teknologi CPU baru membuatnya lebih cepat dari memori lagi, cache akan muncul kembali. Dalam biologi, kepunahan adalah selamanya, tetapi dalam ilmu komputer, kadang-kadang hanya untuk beberapa tahun.

Sebagai konsekuensi dari ketidakkekalan ini, dalam buku ini kita dari waktu ke waktu akan waktu melihat konsep ''usang'', yaitu ide-ide yang tidak optimal dengan saat ini teknologi. Namun, perubahan dalam teknologi dapat membawa kembali beberapa apa yang disebut ''konsep usang.'' Untuk alasan ini, penting untuk memahami mengapa konsep sudah usang dan perubahan lingkungan apa yang mungkin membawanya kembali.

Untuk memperjelas poin ini, mari kita perhatikan contoh sederhana. Komputer awal memiliki set instruksi bawaan. Instruksi dieksekusi langsung oleh perangkat keras dan tidak dapat diubah. Kemudian datanglah microprogramming (pertama kali diperkenalkan pada skala besar dengan IBM 360), di mana penerjemah yang mendasarinya melakukan "instruksi perangkat keras" dalam perangkat lunak. Eksekusi bawaan menjadi usang. Dia tidak cukup fleksibel. Kemudian komputer RISC ditemukan, dan pemrograman mikro (yaitu, eksekusi yang ditafsirkan) menjadi usang karena eksekusi langsung lebih cepat. Sekarang kita melihat kebangkitan tafsir dalam bentuk Jawa applet yang dikirim melalui Internet dan ditafsirkan pada saat kedatangan. Kecepatan eksekusi tidak selalu penting karena penundaan jaringan sangat besar sehingga cenderung mendominasi. Dengan demikian pendulum telah berayun beberapa siklus antara eksekusi langsung dan interpretasi dan mungkin masih berayun lagi di masa depan.

**Kenangan Besar**

Sekarang mari kita periksa beberapa perkembangan historis dalam perangkat keras dan bagaimana mereka telah mempengaruhi perangkat lunak berulang kali. Mainframe pertama memiliki memori yang terbatas. SEBUAH IBM 7090 atau 7094 yang terisi penuh, yang berperan sebagai raja gunung dari akhir tahun 1959 sampai tahun 1964, hanya memiliki lebih dari 128 KB memori. Itu sebagian besar diprogram dalam bahasa rakitan dan sistem operasinya ditulis dalam bahasa rakitan untuk menyimpan memori berharga.

Seiring berjalannya waktu, kompiler untuk bahasa seperti FORTRAN dan COBOL mendapat cukup baik sehingga bahasa assembly diucapkan mati. Tapi ketika pertama komputer mini komersial (PDP-1) dirilis, hanya memiliki 4096 kata 18-bit memori, dan bahasa rakitan membuat kejutan kembali. Akhirnya, komputer mini memperoleh lebih banyak memori dan bahasa tingkat tinggi menjadi lazim di mereka.

Ketika mikrokomputer muncul pada awal 1980-an, yang pertama memiliki memori 4-KB dan pemrograman bahasa rakitan bangkit dari kematian. Komputer tertanam sering menggunakan chip CPU yang sama dengan mikrokomputer (8080, Z80, dan kemudian 8086s) dan juga diprogram dalam assembler pada awalnya. Sekarang keturunan mereka, komputer pribadi, memiliki banyak memori dan diprogram dalam C, C++, Java, dan bahasa tingkat tinggi lainnya. Kartu pintar mengalami hal serupa pengembangan, meskipun di luar ukuran tertentu, kartu pintar sering memiliki Java penerjemah dan menjalankan program Java secara interpretatif, daripada membuat Java menjadi dikompilasi ke bahasa mesin kartu pintar.

**Perangkat Keras Perlindungan**

Mainframe awal, seperti IBM 7090/7094, tidak memiliki perangkat keras perlindungan, jadi mereka hanya menjalankan satu program pada satu waktu. Program buggy dapat menghapus sistem operasi dan dengan mudah membuat mesin crash. Dengan diperkenalkannya IBM 360, bentuk primitif perlindungan perangkat keras menjadi tersedia. Mesin ini bisa kemudian simpan beberapa program di memori secara bersamaan dan biarkan mereka bergiliran berjalan (multiprogram). Monoprogramming dinyatakan usang.

Setidaknya sampai komputer mini pertama muncul—tanpa perangkat keras proteksi—jadi multiprogramming tidak mungkin dilakukan. Meskipun PDP-1 dan PDP-8 tidak memiliki perangkat keras proteksi, akhirnya PDP-11 melakukannya, dan fitur ini menghasilkan multiprogramming dan akhirnya ke UNIX. Ketika mikrokomputer pertama dibuat, mereka menggunakan chip CPU Intel 8080, yang tidak memiliki perlindungan perangkat keras, jadi kami kembali ke pemrograman tunggal—satu program dalam memori pada suatu waktu. Tidak sampai chip Intel 80286 yang melindungi perangkat keras ditambahkan dan multiprogramming menjadi mungkin. Sampai hari ini, banyak sistem tertanam tidak memiliki perangkat keras perlindungan dan hanya menjalankan satu program. Sekarang mari kita lihat sistem operasi. Mainframe pertama awalnya tidak memiliki perangkat keras perlindungan dan tidak ada dukungan untuk multiprogramming, sehingga mereka menjalankan sistem operasi sederhana yang menangani satu program yang dimuat secara manual pada satu waktu. Kemudian mereka memperoleh dukungan perangkat keras dan sistem operasi untuk menangani banyak program di sekali, dan kemudian kemampuan timesharing penuh.

Ketika komputer mini pertama kali muncul, mereka juga tidak memiliki perangkat keras perlindungan dan menjalankan satu program yang dimuat secara manual pada satu waktu, meskipun multiprogramming adalah mapan di dunia mainframe saat itu. Secara bertahap, mereka memperoleh perangkat keras perlindungan dan kemampuan untuk menjalankan dua atau lebih program sekaligus. Pertama mikrokomputer juga hanya mampu menjalankan satu program pada satu waktu, tetapi kemudian memperoleh kemampuan untuk multiprogram. Komputer genggam dan kartu pintar pergi rute yang sama.

Dalam semua kasus, pengembangan perangkat lunak ditentukan oleh teknologi. Pertama mikrokomputer, misalnya, memiliki memori sekitar 4 KB dan tidak ada perangkat keras perlindungan. Bahasa tingkat tinggi dan multiprogramming terlalu berlebihan untuk sistem sekecil itu untuk ditangani. Ketika mikrokomputer berevolusi menjadi komputer pribadi modern, mereka memperoleh perangkat keras yang diperlukan dan kemudian perangkat lunak yang diperlukan untuk menangani fitur yang lebih canggih. Kemungkinan besar perkembangan ini akan terus berlanjut selama bertahun-tahun yang akan datang. Bidang lain mungkin juga memiliki roda reinkarnasi ini, tapi di industri komputer tampaknya berputar lebih cepat.

**Disk**

Mainframe awal sebagian besar berbasis pita magnetik. Mereka akan membaca dalam program dari kaset, mengkompilasinya, menjalankannya, dan menulis hasilnya kembali ke kaset lain. Di sana tidak ada disk dan tidak ada konsep sistem file. Itu mulai berubah ketika IBM memperkenalkan hard disk pertama—RAMAC (RANdoM ACcess) pada tahun 1956. Ini menempati sekitar 4 meter persegi luas lantai dan dapat menyimpan 5 juta karakter 7-bit, cukup untuk satu foto digital resolusi menengah. Tapi dengan biaya sewa tahunan dari $ 35.000, merakit cukup untuk menyimpan setara dengan rol film yang didapat mahal cukup cepat. Tapi akhirnya harga turun dan sistem file primitif dikembangkan.

Khas dari pengembangan baru ini adalah CDC 6600, diperkenalkan pada tahun 1964 dan selama bertahun-tahun komputer tercepat di dunia. Pengguna dapat membuat apa yang disebut "file permanen" dengan memberi mereka nama dan berharap tidak ada pengguna lain yang juga memutuskan bahwa, katakanlah, "data" adalah nama yang cocok untuk sebuah file. Ini adalah direktori tingkat tunggal. Akhirnya, mainframe mengembangkan sistem file hierarkis yang kompleks, mungkin berpuncak pada sistem file MULTICS.

Ketika komputer mini mulai digunakan, mereka akhirnya juga memiliki hard disk. Itu disk standar pada PDP-11 ketika diperkenalkan pada tahun 1970 adalah disk RK05, dengan kapasitas 2,5 MB, sekitar setengah dari IBM RAMAC, tetapi hanya sekitar Diameter 40 cm dan tinggi 5 cm. Tapi itu juga memiliki direktori tingkat tunggal pada awalnya. Ketika mikrokomputer keluar, CP/M pada awalnya merupakan sistem operasi yang dominan, dan juga hanya mendukung satu direktori pada (floppy) disk.

**Memori Virtual**

Memori virtual (dibahas di Bab 3) memberikan kemampuan untuk menjalankan program yang lebih besar dari memori fisik mesin dengan cepat memindahkan potongan-potongan menjadi tween RAM dan disk. Itu mengalami perkembangan serupa, pertama kali muncul di mainframe, lalu pindah ke mini dan mikro. Memori virtual juga memungkinkan ed memiliki tautan program secara dinamis di perpustakaan pada saat dijalankan alih-alih memilikinya dikompilasi. MULTICS adalah sistem pertama yang mengizinkan ini. Akhirnya ide disebarkan ke bawah garis dan sekarang banyak digunakan di sebagian besar UNIX dan Windows sistem.

Dalam semua perkembangan ini, kami melihat ide-ide diciptakan dalam satu konteks dan kemudian dibuang ketika konteksnya berubah (pemrograman bahasa rakitan, tata bahasa monopro, direktori tingkat tunggal, dll.) hanya untuk muncul kembali dalam konteks yang berbeda sering satu dekade kemudian. Untuk alasan ini dalam buku ini kita kadang-kadang akan melihat ide-ide dan algoritme yang mungkin tampak kuno pada PC gigabyte saat ini, tetapi mungkin akan segera kembali pada komputer tertanam dan kartu pintar.

## 1.6 PANGGILAN SISTEM

Kita telah melihat bahwa sistem operasi memiliki dua fungsi utama: menyediakan abstraksi ke program pengguna dan mengelola sumber daya komputer. Untuk sebagian besar bagian, interaksi antara program pengguna dan sistem operasi berhubungan dengan mantan; misalnya membuat, menulis, membaca, dan menghapus file. Bagian re source-management sebagian besar transparan bagi pengguna dan dilakukan secara otomatis.

Dengan demikian, antarmuka antara program pengguna dan sistem operasi terutama tentang berurusan dengan abstraksi. Untuk benar-benar memahami apa itu sistem operasi lakukan, kita harus memeriksa antarmuka ini dengan cermat. Panggilan sistem yang tersedia di antarmuka bervariasi dari satu sistem operasi ke sistem operasi lainnya (walaupun konsep dasarnya cenderung mirip).

Dengan demikian kami dipaksa untuk membuat pilihan antara (1) generalisasi yang tidak jelas ("sistem operasi memiliki panggilan sistem untuk membaca file") dan (2) beberapa sistem tertentu ("UNIX memiliki panggilan sistem baca dengan tiga parameter: satu untuk menentukan file, satu untuk memberi tahu di mana data harus diletakkan, dan satu untuk memberi tahu berapa byte yang harus dibaca").

Kami telah memilih pendekatan yang terakhir. Lebih banyak pekerjaan seperti itu, tetapi memberi lebih banyak wawasan tentang apa yang sebenarnya dilakukan sistem operasi. Meskipun diskusi ini secara khusus mengacu pada POSIX (Standar Internasional 9945-1), maka juga untuk UNIX, Sistem V, BSD, Linux, MINIX 3, dan seterusnya, sebagian besar sistem operasi modern lainnya memiliki panggilan sistem yang menjalankan fungsi yang sama, meskipun detailnya berbeda. Sejak yang sebenarnya mekanisme mengeluarkan panggilan sistem sangat bergantung pada mesin dan sering kali harus diekspresikan dalam kode perakitan, perpustakaan prosedur disediakan untuk memungkinkannya untuk membuat panggilan sistem dari program C dan sering juga dari bahasa lain.

Hal ini berguna untuk mengingat hal-hal berikut. Setiap komputer dengan CPU tunggal hanya dapat mengeksekusi satu instruksi pada satu waktu. Jika suatu proses menjalankan program pengguna di pengguna mode dan membutuhkan layanan sistem, seperti membaca data dari file, itu harus dijalankan instruksi perangkap untuk mentransfer kontrol ke sistem operasi. Sistem operasi kemudian mencari tahu apa yang diinginkan oleh proses pemanggilan dengan memeriksa parameternya. Kemudian itu melakukan panggilan sistem dan mengembalikan kontrol ke instruksi yang mengikuti panggilan sistem. Dalam arti tertentu, membuat panggilan sistem seperti membuat jenis panggilan prosedur khusus, hanya panggilan sistem yang masuk ke kernel dan panggilan prosedur tidak.

Untuk membuat mekanisme panggilan sistem lebih jelas, mari kita lihat sekilas bacaannya panggilan sistem. Seperti disebutkan di atas, ia memiliki tiga parameter: yang pertama menentukan file, yang kedua menunjuk ke buffer, dan yang ketiga memberikan nomor byte untuk dibaca. Seperti hampir semua panggilan sistem, ia dipanggil dari program C dengan memanggil prosedur perpustakaan dengan nama yang sama dengan panggilan sistem: baca. Panggilan dari Program C mungkin terlihat seperti ini:

count = read(fd, buffer, nbytes);

Panggilan sistem (dan prosedur perpustakaan) mengembalikan jumlah byte sebenarnya membaca dalam hitungan. Nilai ini biasanya sama dengan nbyte, tetapi mungkin lebih kecil, jika, misalnya, end-of-file ditemui saat membaca.

Jika panggilan sistem tidak dapat dilakukan karena parameter atau disk yang tidak valid kesalahan, hitungan diatur ke 1, dan nomor kesalahan dimasukkan ke dalam variabel global, errno.

Program harus selalu memeriksa hasil panggilan sistem untuk melihat apakah terjadi kesalahan. Panggilan sistem dilakukan dalam serangkaian langkah. Untuk memperjelas konsep ini, mari kita periksa panggilan baca yang dibahas di atas. Dalam persiapan untuk memanggil prosedur read li brary, yang sebenarnya membuat panggilan sistem baca, program panggilan pertama mendorong parameter ke tumpukan, seperti yang ditunjukkan pada langkah 1-3 pada Gambar. 1-17.

Kompiler C dan C++ mendorong parameter ke tumpukan dalam urutan terbalik untuk alasan historis (berkaitan dengan membuat parameter pertama ke printf, string for mat, muncul di atas tumpukan). Parameter pertama dan ketiga disebut dengan nilai, tetapi parameter kedua dilewatkan dengan referensi, yang berarti bahwa alamat dari buffer (ditunjukkan oleh &) dilewatkan, bukan isi buffer. Kemudian datang panggilan sebenarnya ke prosedur perpustakaan (langkah 4). Instruksi ini adalah instruksi prosedur dure-call normal yang digunakan untuk memanggil semua prosedur.

Prosedur perpustakaan, mungkin ditulis dalam bahasa rakitan, biasanya menempatkan: nomor panggilan sistem di tempat yang diharapkan oleh sistem operasi, seperti: mendaftar (langkah 5). Kemudian mengeksekusi instruksi TRAP untuk beralih dari mode pengguna ke mode kernel dan mulai eksekusi pada alamat tetap di dalam kernel (langkah 6).Itu Instruksi TRAP sebenarnya cukup mirip dengan instruksi procedure-call merasakan bahwa instruksi yang mengikutinya diambil dari lokasi yang jauh dan kembali alamat disimpan di tumpukan untuk digunakan nanti.

![image](https://user-images.githubusercontent.com/112523858/189549026-432b367f-5a75-4f73-9078-7bec1074ceb5.png)

Gambar 1-17. 11 langkah dalam membuat panggilan sistem dibaca (fd, buffer, nbytes).

Namun demikian, instruksi TRAP juga berbeda dari instruksi pemanggilan prosedur dalam dua hal mendasar. Pertama, sebagai efek samping, ia beralih ke mode kernel. Instruksi panggilan prosedur tidak mengubah mode. Kedua, daripada memberikan alamat relatif atau absolut di mana prosedur berada, instruksi TRAP tidak dapat melompat ke alamat sembarang. Tergantung pada arsitekturnya, entah itu melompat ke satu lokasi tetap atau ada bidang 8-bit dalam pemberian instruksi indeks ke dalam tabel di memori yang berisi alamat lompatan, atau yang setara.

Kode kernel yang mulai mengikuti TRAP memeriksa nomor panggilan sistem dan kemudian mengirimkan ke pengendali panggilan sistem yang benar, biasanya melalui tabel pointer ke penangan panggilan sistem yang diindeks pada nomor panggilan sistem (langkah 7). Saat itu arahkan pengendali panggilan sistem berjalan (langkah 8). Setelah menyelesaikan pekerjaannya, kontrol dapat dikembalikan ke prosedur perpustakaan ruang pengguna dengan instruksi berikut: instruksi TRAP (langkah 9). Prosedur ini kemudian kembali ke program pengguna di prosedur cara biasa memanggil kembali (langkah 10).

Untuk menyelesaikan pekerjaan, program pengguna harus membersihkan tumpukan, seperti yang dilakukan setelahnya setiap panggilan prosedur (langkah 11). Dengan asumsi tumpukan tumbuh ke bawah, seperti yang sering terjadi tidak, kode yang dikompilasi menambah penunjuk tumpukan cukup tepat untuk menghapus parameter didorong sebelum panggilan untuk membaca. Program ini sekarang bebas melakukan apa saja ingin dilakukan selanjutnya.

Pada langkah 9 di atas, kami mengatakan "dapat dikembalikan ke prosedur perpustakaan ruang pengguna" untuk alasan yang baik. Panggilan sistem dapat memblokir penelepon, mencegahnya melanjutkan. Misalnya, jika mencoba membaca dari keyboard dan tidak ada yang diketik, penelepon harus diblokir. Dalam hal ini, sistem operasi akan terlihat sekitar untuk melihat apakah beberapa proses lain dapat dijalankan selanjutnya. Nanti, ketika input yang diinginkan tersedia, proses ini akan mendapatkan perhatian dari sistem dan menjalankan langkah 9-11.

Di bagian berikut, kami akan memeriksa beberapa yang paling banyak digunakan Panggilan sistem POSIX, atau lebih khusus lagi, prosedur perpustakaan yang membuat itu panggilan sistem. POSIX memiliki sekitar 100 panggilan prosedur. Beberapa yang paling penting yang tercantum pada Gambar. 1-18, dikelompokkan untuk kenyamanan dalam empat kategori. Dalam teks kita akan secara singkat memeriksa setiap panggilan untuk melihat apa yang dilakukannya. Untuk sebagian besar, layanan yang ditawarkan oleh panggilan ini menentukan sebagian besar dari apa yang sistem operasi harus dilakukan, karena manajemen sumber daya pada komputer pribadi minimal (setidaknya dibandingkan dengan mesin besar dengan banyak pengguna). Itu layanan mencakup hal-hal seperti membuat dan mengakhiri proses, membuat, menghapus, membaca, dan menulis file, mengelola direktori, dan melakukan input dan output.

Selain itu, perlu ditunjukkan bahwa pemetaan prosedur POSIX panggilan ke panggilan sistem tidak satu-ke-satu. Standar POSIX menentukan nomor prosedur yang harus disediakan oleh sistem konforman, tetapi tidak menentukan apakah itu panggilan sistem, panggilan perpustakaan, atau sesuatu yang lain. Jika suatu prosedur dapat dijalankan tanpa memanggil panggilan sistem (yaitu, tanpa menjebak ke kernel), itu akan biasanya dilakukan di ruang pengguna karena alasan kinerja. Namun, sebagian besar Prosedur POSIX melakukan panggilan sistem, biasanya dengan satu pemetaan prosedur langsung ke satu panggilan sistem. Dalam beberapa kasus, terutama di mana beberapa prosedur yang diperlukan hanyalah variasi kecil satu sama lain, satu panggilan sistem menangani lebih banyak dari satu panggilan perpustakaan.

### 1.6.1 Panggilan Sistem untuk Manajemen Proses

Kelompok panggilan pertama pada Gambar 1-18 berhubungan dengan manajemen proses. Garpu adalah tempat yang baik untuk memulai diskusi. Fork adalah satu-satunya cara untuk membuat proses baru di POSIX. Itu membuat duplikat yang tepat dari proses asli, termasuk semua file deskriptor, register—semuanya. Setelah garpu, proses asli dan salinan (orang tua dan anak) berpisah. Semua variabel memiliki nilai identik pada saat fork, tetapi karena data induk disalin untuk membuat turunan, perubahan berikutnya di salah satu dari mereka tidak mempengaruhi yang lain. (Teks program, yang tidak dapat diubah, dibagi antara orang tua dan anak.) Panggilan fork mengembalikan nilai, yaitu nol pada anak dan sama dengan PID anak (Pengidentifikasi Proses) di induk. Menggunakan PID yang dikembalikan, kedua proses dapat melihat yang mana yang proses induk dan mana yang merupakan proses anak

![image](https://user-images.githubusercontent.com/112523858/189549194-65da69aa-3844-43c3-8c6d-ef25e87d2c74.png)

Gambar 1-18. Beberapa panggilan sistem POSIX utama. Kode pengembalian s adalah 1 jika Sebuah kesalahan telah terjadi. Kode pengembalian adalah sebagai berikut: pid adalah id proses, fd adalah deskriptor file, n adalah jumlah byte, posisi adalah offset dalam file, dan detik adalah waktu yang telah berlalu. Parameter dijelaskan dalam teks.

Dalam kebanyakan kasus, setelah percabangan, anak perlu mengeksekusi kode yang berbeda dari orang tua. Pertimbangkan kasus shell. Itu membaca perintah dari terminal, memotong proses anak, menunggu anak menjalankan perintah, dan kemudian membaca perintah berikutnya ketika anak berakhir. Untuk menunggu anak selesai, orang tua mengeksekusi panggilan sistem waitpid, yang hanya menunggu sampai anak berakhir (setiap anak jika ada lebih dari satu). Waitpid dapat menunggu anak tertentu, atau untuk apa pun anak tua dengan mengatur parameter pertama ke 1. Ketika waitpid selesai, alamatnya ditunjukkan oleh parameter kedua, statloc, akan disetel ke proses anak keluar status (terminasi normal atau abnormal dan nilai keluar). Berbagai pilihan juga disediakan, ditentukan oleh parameter ketiga. Misalnya, segera kembali jika belum ada anak yang keluar.

Sekarang perhatikan bagaimana garpu digunakan oleh cangkang. Ketika sebuah perintah diketik, shell memotong proses baru. Proses anak ini harus menjalankan perintah pengguna. Ia melakukan ini dengan menggunakan panggilan sistem eksekutif, yang menyebabkan seluruh gambar inti menjadi digantikan oleh file yang disebutkan dalam parameter pertamanya. (Sebenarnya, sistem memanggil dirinya sendiri adalah exec, tetapi beberapa prosedur perpustakaan menyebutnya dengan parameter yang berbeda dan sedikit nama yang berbeda. Kami akan memperlakukan ini sebagai panggilan sistem di sini.) Shell yang sangat disederhanakan menggambarkan penggunaan fork, waitpid, dan execve ditunjukkan pada Gambar. 1-19

![image](https://user-images.githubusercontent.com/112523858/189549263-ccb63225-e16f-4bca-ae7d-68f156bc2596.png)

Gambar 1-19. Cangkang yang dilucuti. Sepanjang buku ini, TRUE diasumsikan didefinisikan sebagai 1.

Dalam kasus yang paling umum, execve memiliki tiga parameter: nama file untuk dieksekusi, pointer ke array argumen, dan pointer ke lingkungan Himpunan. Ini akan dijelaskan segera. Berbagai rutinitas perpustakaan, termasuk execl, execv, execle, dan execve, disediakan untuk memungkinkan parameter dihilangkan atau ditentukan dengan berbagai cara. Sepanjang buku ini kami akan menggunakan nama exec untuk mewakili panggilan sistem yang dipanggil oleh semua ini.

Mari kita pertimbangkan kasus perintah seperti

cp file1 file2

digunakan untuk menyalin file1 ke file2. Setelah shell bercabang, proses anak menemukan dan mengeksekusi file cp dan memberikannya nama file sumber dan target. Program utama cp (dan program utama dari sebagian besar program C lainnya) berisi deklarasi

utama (argc, argv, envp)

di mana argc adalah hitungan jumlah item pada baris perintah, termasuk nama program. Untuk contoh di atas, argc adalah 3. Parameter kedua, argv, adalah penunjuk ke array. Elemen i dari array itu adalah a pointer ke string ke-i pada baris perintah. Dalam contoh kita, argv[0] akan menunjuk ke string "cp", argv[1] akan menunjuk ke string "file1", dan argv[2] akan arahkan ke string "file2".

Parameter ketiga dari main, envp, adalah penunjuk ke lingkungan, array dari string yang berisi tugas dari nama formulir = nilai yang digunakan untuk menyampaikan informasi seperti jenis terminal dan nama direktori home ke program. Ada perpustakaan prosedur yang dapat dipanggil oleh program untuk mendapatkan variabel lingkungan, yang sering kali digunakan untuk menyesuaikan bagaimana pengguna ingin melakukan tugas-tugas tertentu (misalnya, printer default yang akan digunakan). Pada Gambar 1-19, tidak ada lingkungan yang diteruskan ke anak, jadi parameter ketiga dari eksekutif adalah nol.

Jika exec tampak rumit, jangan putus asa; ini (secara semantik) yang paling kompleks dari semua panggilan sistem POSIX. Semua yang lain jauh lebih sederhana. Sebagai contoh sederhana, pertimbangkan exit, proses mana yang harus digunakan saat mereka selesai dieksekusi. Ini memiliki satu parameter, status keluar (0 hingga 255), yang dikembalikan ke induk melalui statloc dalam panggilan sistem waitpid.

Proses di UNIX memiliki memori yang dibagi menjadi tiga segmen: teks segmen (yaitu, kode program), segmen data (yaitu, variabel), dan segmen tumpukan. Segmen data tumbuh ke atas dan tumpukan tumbuh ke bawah, seperti yang ditunjukkan pada Gambar. 1-20. Di antara mereka ada celah ruang alamat yang tidak digunakan. Tumpukan tumbuh ke celah secara otomatis, sesuai kebutuhan, tetapi perluasan segmen data adalah dilakukan secara eksplisit dengan menggunakan panggilan sistem, br k, yang menentukan alamat baru di mana segmen data akan berakhir. Panggilan ini, bagaimanapun, tidak didefinisikan oleh standar POSIX, karena programmer didorong untuk menggunakan prosedur perpustakaan malloc untuk mengalokasikan penyimpanan secara dinamis, dan implementasi yang mendasari malloc adalah tidak dianggap sebagai subjek yang cocok untuk standardisasi karena hanya sedikit programmer yang menggunakannya secara langsung dan diragukan bahwa ada orang yang menyadari bahwa br k tidak ada di POSIX.

### 1.6.2 Panggilan Sistem untuk Manajemen File

Banyak panggilan sistem berhubungan dengan sistem file. Di bagian ini kita akan melihat panggilan yang beroperasi pada file individual; berikutnya kita akan memeriksa mereka yang melibatkan direktori atau sistem file secara keseluruhan.

Untuk membaca atau menulis file, file harus dibuka terlebih dahulu. Panggilan ini menentukan nama file untuk dibuka, baik sebagai nama path absolut atau relatif terhadap direktori kerja, serta kode O RDONLY, O WRONLY, atau O RDWR, artinya terbuka untuk membaca, menulis, atau keduanya. Untuk membuat file baru, parameter O CREAT digunakan 

![image](https://user-images.githubusercontent.com/112523858/189551173-1d993ad6-ff78-4263-b45f-4589c5660164.png)

Gambar 1-20. Proses memiliki tiga segmen: teks, data, dan tumpukan.

Deskriptor file yang dikembalikan kemudian dapat digunakan untuk membaca atau menulis. Setelah itu, file dapat ditutup dengan menutup, yang membuat deskriptor file tersedia untuk digunakan kembali pada selanjutnya terbuka.

Panggilan yang paling banyak digunakan tidak diragukan lagi adalah panggilan baca dan tulis. Kami melihat membaca lebih awal. Wr ite memiliki parameter yang sama. Meskipun sebagian besar program membaca dan menulis file secara berurutan, untuk beberapa aplikasi, program harus dapat mengakses bagian mana pun dari file secara acak. Terkait dengan setiap file adalah pointer yang menunjukkan posisi saat ini dalam file. Saat membaca (menulis) secara berurutan, biasanya menunjuk ke byte berikutnya untuk dibaca (ditulis).

Panggilan lseek mengubah nilai penunjuk posisi, sehingga panggilan berikutnya ke membaca atau menulis dapat dimulai di mana saja dalam file. Lseek memiliki tiga parameter: yang pertama adalah deskriptor file untuk file tersebut, yang kedua adalah posisi file, dan yang ketiga memberi tahu apakah posisi file relatif terhadap awal file, posisi saat ini, atau akhir file. Nilai yang dikembalikan oleh lseek adalah posisi absolut dalam file (dalam byte) setelah mengubah pointer.

Untuk setiap file, UNIX melacak mode file (file biasa, file khusus, direktori, dan sebagainya), ukuran, waktu modifikasi terakhir, dan informasi lainnya. Pro gram dapat meminta untuk melihat informasi ini melalui panggilan sistem stat. Parameter pertama menentukan file yang akan diperiksa; yang kedua adalah penunjuk ke struktur di mana informasi yang akan diletakkan. Panggilan fstat melakukan hal yang sama untuk file yang terbuka.

### 1.6.3 Panggilan Sistem untuk Manajemen Direktori

Di bagian ini kita akan melihat beberapa panggilan sistem yang lebih berhubungan dengan direktori atau sistem file secara keseluruhan, bukan hanya untuk satu file tertentu seperti sebelumnya bagian. Dua panggilan pertama, mkdir dan rmdir, membuat dan menghapus direktori kosong, masing-masing. Panggilan berikutnya adalah tautan. Tujuannya adalah untuk memungkinkan file yang sama muncul di bawah dua atau lebih nama, seringkali di direktori yang berbeda. Penggunaan tipikal adalah untuk mengizinkan beberapa anggota tim pemrograman yang sama untuk berbagi file yang sama, dengan masing-masing dari mereka memiliki file yang muncul di direktorinya sendiri, mungkin dengan nama yang berbeda.

Berbagi file tidak sama dengan memberikan salinan pribadi kepada setiap anggota tim; memiliki file bersama berarti bahwa perubahan yang dibuat oleh setiap anggota tim secara instan terlihat oleh anggota lain—hanya ada satu file. Ketika salinan dibuat dari file, perubahan selanjutnya yang dilakukan pada satu salinan tidak memengaruhi salinan lainnya.

Untuk melihat bagaimana link bekerja, perhatikan situasi pada Gambar 1-21(a). Berikut adalah dua pengguna, ast dan jim, masing-masing memiliki direktori sendiri dengan beberapa file. Jika ast sekarang menjalankan program yang berisi panggilan sistem 

link("/usr/jim/memo", "/usr/ast/catatan");

file memo di direktori jim sekarang dimasukkan ke direktori ast dengan nama catatan. Setelah itu, /usr/jim/memo dan /usr/ast/note merujuk ke file yang sama. sebagai selain itu, apakah direktori pengguna disimpan di /usr, /user, /home, atau di tempat lain hanya keputusan yang dibuat oleh administrator sistem lokal

![image](https://user-images.githubusercontent.com/112523858/189551315-46c25449-1093-4a52-b0cd-1aab70f36fc6.png)

Gambar 1-21. (a) Dua direktori sebelum menghubungkan /usr/jim/memo ke direktori ast. (b) Direktori yang sama setelah ditautkan.

Memahami cara kerja tautan mungkin akan memperjelas fungsinya. Setiap file di UNIX memiliki nomor unik, nomor-i, yang mengidentifikasinya. Ini i-number adalah indeks ke dalam tabel i-node, satu per file, memberi tahu siapa pemilik file, di mana blok disknya, dan seterusnya. Direktori hanyalah sebuah file yang berisi sekumpulan (nomor-i, nama ASCII) berpasangan. Dalam versi pertama UNIX, setiap entri direktori adalah 16 byte—2 byte untuk nomor-i dan 14 byte untuk nama. Sekarang lebih banyak struktur yang rumit diperlukan untuk mendukung nama file yang panjang, tetapi secara konseptual direktori masih merupakan sekumpulan pasangan (nomor-i, nama ASCII). Pada Gambar 1-21, surat memiliki i-num ber 16, dan seterusnya. Apa yang dilakukan tautan hanyalah membuat entri direktori baru dengan nama (mungkin baru), menggunakan nomor-i dari file yang ada. Pada Gambar. 1-21(b), dua entri memiliki nomor-i yang sama (70) dan dengan demikian merujuk ke file yang sama. Jika salah satunya adalah kemudian dihapus, menggunakan panggilan sistem batalkan tautan, yang lainnya tetap ada. Jika keduanya dipindahkan, UNIX melihat bahwa tidak ada entri ke file yang ada (bidang di i-node melacak dari jumlah entri direktori yang menunjuk ke file), sehingga file tersebut dihapus dari disk.

Seperti yang telah kami sebutkan sebelumnya, panggilan sistem mount memungkinkan dua sistem file untuk digabung menjadi satu. Situasi umum adalah memiliki sistem file root, yang berisi versi biner (yang dapat dieksekusi) dari perintah umum dan lainnya yang banyak digunakan file, pada hard disk (sub)partisi dan file pengguna pada (sub)partisi lain. Lebih jauh, pengguna kemudian dapat memasukkan disk USB dengan file untuk dibaca.

Dengan menjalankan panggilan sistem mount, sistem file USB dapat dilampirkan ke sistem file root, seperti yang ditunjukkan pada Gambar. 1-22. Pernyataan khas dalam C untuk me-mount adalah

mount("/dev/sdb0", "/mnt", 0);

di mana parameter pertama adalah nama file khusus blok untuk drive USB 0, the parameter kedua adalah tempat di pohon tempat ia akan dipasang, dan yang ketiga parameter memberitahu apakah sistem file akan dipasang read-write atau read-only.

![image](https://user-images.githubusercontent.com/112523858/189551348-4362205e-c0e9-46b9-a400-8dc7cf1cd160.png)

Gambar 1-22. (a) Sistem file sebelum pemasangan. (b) Sistem file setelah mount.

Setelah panggilan mount, file di drive 0 dapat diakses hanya dengan menggunakan jalurnya dari direktori root atau direktori kerja, tanpa memperhatikan drive mana itu pada. Bahkan, drive kedua, ketiga, dan keempat juga dapat dipasang di mana saja di pohon. Panggilan pemasangan memungkinkan untuk mengintegrasikan media yang dapat dilepas ke dalam satu hierarki file terintegrasi, tanpa harus khawatir tentang perangkat tempat file berada.

Meskipun contoh ini melibatkan CD-ROM, bagian dari hard disk (sering disebut partisi atau perangkat kecil) juga dapat dipasang dengan cara ini, serta eksternal hard disk dan stik USB. Ketika sistem file tidak lagi diperlukan, itu bisa menjadi dilepas dengan panggilan sistem umount.

### 1.6.4 Panggilan Sistem Lain-Lain

Berbagai panggilan sistem lain juga ada. Kami akan melihat hanya empat dari mereka di sini. Panggilan chdir mengubah direktori kerja saat ini. Setelah panggilan

chdir("/usr/ast/tes");

pembukaan pada file xyz akan membuka /usr/ast/test/xyz. Konsep direktori kerja menghilangkan kebutuhan untuk mengetik nama path absolut (panjang) sepanjang waktu. Di UNIX setiap file memiliki mode yang digunakan untuk perlindungan. Modus termasuk baca-tulis-eksekusi bit untuk pemilik, grup, dan lainnya. Panggilan sistem chmod memungkinkan untuk mengubah mode file. Misalnya, untuk membuat file hanya dapat dibaca oleh semua orang kecuali pemiliknya, seseorang dapat mengeksekusi

chmod("berkas", 0644);

Kill system call adalah cara pengguna dan proses pengguna mengirim sinyal. Jika suatu proses disiapkan untuk menangkap sinyal tertentu, maka ketika tiba, penangan sinyal adalah: Lari. Jika proses tidak dipersiapkan untuk menangani sinyal, maka kedatangannya akan mematikan proses (karenanya nama panggilannya). POSIX mendefinisikan sejumlah prosedur untuk menangani waktu. Sebagai contoh, waktu baru saja mengembalikan waktu saat ini dalam hitungan detik, dengan 0 sesuai dengan 1 Januari 1970 tengah malam (saat hari baru dimulai, bukan berakhir). Pada komputer yang menggunakan 32-bit kata, nilai maksimum waktu dapat kembali adalah 232 1 detik (dengan asumsi bilangan bulat unsigned digunakan). Nilai ini sesuai dengan sedikit lebih dari 136 tahun. Jadi dalam tahun 2106, sistem UNIX 32-bit akan mengamuk, tidak seperti masalah Y2K terkenal yang akan mendatangkan malapetaka dengan komputer dunia pada tahun 2000, apakah itu bukan karena upaya besar-besaran yang dilakukan industri TI untuk memperbaiki masalah. Jika Anda saat ini memiliki sistem UNIX 32-bit, Anda disarankan untuk menukarnya dengan sistem 64-bit beberapa waktu sebelum tahun 2106.

### 1.6.5 Windows Win32 API

Sejauh ini kami telah berfokus terutama pada UNIX. Sekarang saatnya untuk melihat secara singkat jendela. Windows dan UNIX berbeda secara mendasar dalam model pemrograman masing-masing. Program UNIX terdiri dari kode yang melakukan sesuatu atau lainnya, membuat panggilan sistem untuk menjalankan layanan tertentu. Sebaliknya, program Windows biasanya digerakkan oleh peristiwa. Program utama menunggu beberapa acara untuk terjadi, kemudian memanggil prosedur untuk menanganinya. Peristiwa khas adalah kunci dipukul, mouse dipindahkan, tombol mouse ditekan, atau drive USB dimasukkan.

Penangan kemudian dipanggil untuk memproses acara, memperbarui layar dan memperbarui status program internal. Secara keseluruhan, ini mengarah pada gaya pemrograman yang agak berbeda dibandingkan dengan UNIX, tetapi karena fokus buku ini adalah pada sistem operasi. fungsi dan struktur, model pemrograman yang berbeda ini tidak akan menjadi perhatian kita lebih banyak. Tentu saja, Windows juga memiliki panggilan sistem. Dengan UNIX, hampir ada hubungan satu-ke-satu antara panggilan sistem (misalnya, membaca) dan prosedur perpustakaan (misalnya, baca) digunakan untuk memanggil panggilan sistem. Dengan kata lain, untuk setiap panggilan sistem, kira-kira ada satu prosedur perpustakaan yang dipanggil untuk memanggilnya, seperti yang ditunjukkan dalam Gambar 1-17. Selanjutnya, POSIX hanya memiliki sekitar 100 panggilan prosedur.

Dengan Windows, situasinya sangat berbeda. Untuk mulai dengan, perpustakaan panggilan dan panggilan sistem yang sebenarnya sangat dipisahkan. Microsoft telah mendefinisikan satu set prosedur yang disebut Win32 API (Application Programming Interface) yang programmer diharapkan menggunakan untuk mendapatkan layanan sistem operasi. Antarmuka ini adalah (sebagian) didukung di semua versi Windows sejak Windows 95. Dengan memisahkan antarmuka API dari panggilan sistem yang sebenarnya, Microsoft mempertahankan kemampuan untuk ubah panggilan sistem yang sebenarnya tepat waktu (bahkan dari rilis ke rilis) tanpa invali berkencan dengan program yang ada. Apa yang sebenarnya merupakan Win32 juga sedikit ambigu karena versi Windows terbaru memiliki banyak panggilan baru yang sebelumnya tidak tersedia. Di bagian ini, Win32 berarti antarmuka yang didukung oleh semua versi Windows. Win32 menyediakan kompatibilitas antar versi Windows.

Jumlah panggilan API Win32 sangat besar, berjumlah ribuan. Lebih jauh lagi, sementara banyak dari mereka melakukan panggilan sistem, sejumlah besar dilakukan seluruhnya di ruang pengguna. Akibatnya, dengan Windows itu tidak mungkin untuk melihat apa itu panggilan sistem (yaitu, dilakukan oleh kernel) dan apa itu hanya panggilan perpustakaan ruang pengguna. Sebenarnya, apa itu panggilan sistem dalam satu versi Windows dapat dilakukan di ruang pengguna dalam versi yang berbeda, dan sebaliknya. Kapan kami membahas panggilan sistem Windows dalam buku ini, kami akan menggunakan prosedur Win32 (jika sesuai) karena Microsoft menjamin bahwa ini akan stabil selama waktu. Tetapi perlu diingat bahwa tidak semuanya adalah panggilan sistem yang sebenarnya (mis., perangkap ke kernel). Win32 API memiliki sejumlah besar panggilan untuk mengelola jendela, geometris gambar, teks, font, scrollbar, kotak dialog, menu, dan fitur lain dari GUI.

Sejauh subsistem grafis berjalan di kernel (berlaku pada beberapa versi Windows tetapi tidak pada semua), ini adalah panggilan sistem; jika tidak, mereka hanya perpustakaan panggilan. Haruskah kita membahas panggilan ini dalam buku ini atau tidak? Karena mereka tidak benar-benar terkait dengan fungsi sistem operasi, kami telah memutuskan untuk tidak melakukannya, meskipun mereka dapat dilakukan oleh kernel. Pembaca yang tertarik dengan Win32 API harus berkonsultasilah dengan salah satu dari banyak buku tentang masalah ini (misalnya, Hart, 1997; Rektor dan Pendatang baru, 1997; dan Simon, 1997).

Bahkan memperkenalkan semua panggilan API Win32 di sini tidak mungkin, jadi kami akan membatasi diri kita pada panggilan-panggilan yang kira-kira sesuai dengan fungsi dari Panggilan UNIX tercantum pada Gambar 1-18. Ini tercantum pada Gambar. 1-23. Mari kita lihat secara singkat daftar Gambar 1-23. CreateProcess membuat proses baru. Itu melakukan pekerjaan gabungan dari fork dan execve di UNIX. Ini memiliki banyak parameter yang menentukan properti dari proses yang baru dibuat. 

**Windows tidak**

tidak memiliki hierarki proses seperti yang dilakukan UNIX sehingga tidak ada konsep proses induk dan proses anak. Setelah proses dibuat, pencipta dan pencipta adalah sama. WaitForSingleObject digunakan untuk menunggu suatu event. Banyak acara yang mungkin bisa ditunggu. Jika parameter menentukan suatu proses, maka pemanggil menunggu proses tertentu untuk keluar, yang dilakukan menggunakan ExitProcess.

Enam panggilan berikutnya beroperasi pada file dan secara fungsional mirip dengan UNIX mereka rekan-rekan meskipun mereka berbeda dalam parameter dan rincian. Tetap saja, file bisa menjadi dibuka, ditutup, dibaca, dan ditulis hampir sama seperti di UNIX. SetFilePointer dan Panggilan GetFileAttr ibutesEx mengatur posisi file dan mendapatkan beberapa atribut file.

Windows memiliki direktori dan dibuat dengan CreateDirector y dan RemoveDirector y panggilan API, masing-masing. Ada juga gagasan tentang direktori saat ini, yang ditetapkan oleh SetCurrentDirector y. Waktu saat ini diperoleh menggunakan GetLo calTime. Antarmuka Win32 tidak memiliki tautan ke file, sistem file terpasang, keamanan, atau sinyal, sehingga panggilan yang terkait dengan UNIX tidak ada. Tentu saja, Win32 memiliki sejumlah besar panggilan lain yang tidak dimiliki UNIX, terutama untuk mengelola GUI. Windows Vista memiliki sistem keamanan yang rumit dan juga mendukung tautan file port. Windows 7 dan 8 menambahkan lebih banyak fitur dan panggilan sistem.

| UNIX | Win32 | Description | 
| ----------- | :---------: | ---------- | 
| fork | CreateProcess | Create a new process |
| waitpid | WaitForSingleObject | Can wait for a process to |
| exit execve | (none) | CreateProcess = for k + execve |
| exit | ExitProcess | Terminate execution |
| open | CreateFile | Create a file or open an existing file |
| close | CloseHandle | Close a file |
| read | ReadFile | Read data from a file |
| write | WriteFile | Write data to a file |
| lseek | SetFilePointer | Move the file pointer |
| stat | GetFileAttributesEx | Get various file attributes |
|mkdir | CreateDirectory | Create a new directory |
|rmdir |RemoveDirectory | Remove an empty directory |
| link | (none) Win32 does not support links |
| unlink | DeleteFile | Destroy an existing file |
| mount | (none) | Win32 does not support mount | 
| umount | (none) | Win32 does not support mount, so no umount |
| chdir | SetCurrentDirectory | Change the current working directory |
| chmod | (none) | Win32 does not support security (although NT does) |
| kill | (none) | Win32 does not support signals |
| time | GetLocalTime | Get the current time |

Gambar 1-23. Panggilan API Win32 yang kira-kira sesuai dengan panggilan UNIX dari Gambar 1-18. Perlu ditekankan bahwa Windows memiliki sejumlah besar panggilan sistem lainnya, yang sebagian besar tidak sesuai dengan apa pun di UNIX.

Satu catatan terakhir tentang Win32 mungkin layak untuk dibuat. Win32 tidak terlalu buruk antarmuka yang seragam atau konsisten. Penyebab utama di sini adalah kebutuhan untuk kompatibel kembali dengan antarmuka 16-bit sebelumnya yang digunakan di Windows 3.x.

## 1.7 STRUKTUR SISTEM OPERASI

Sekarang kita telah melihat seperti apa sistem operasi di luar (yaitu, antarmuka programmer), sekarang saatnya untuk melihat ke dalam. Pada bagian berikut, kita akan memeriksa enam struktur berbeda yang telah dicoba, untuk mendapatkan: beberapa gagasan tentang spektrum kemungkinan. Ini sama sekali tidak lengkap, tapi mereka memberikan gambaran tentang beberapa desain yang telah dicoba dalam praktek. Enam desain yang akan kita bahas disini adalah sistem monolitik, sistem berlapis, mikrokernel, sistem cli ent-server, mesin virtual, dan eksokernel.

### 1.7.1 Sistem Monolitik

Sejauh ini organisasi yang paling umum, dalam pendekatan monolitik keseluruhan sistem operasi berjalan sebagai satu program dalam mode kernel. Sistem operasinya adalah ditulis sebagai kumpulan prosedur, dihubungkan bersama menjadi satu executable besarprogram biner. Ketika teknik ini digunakan, setiap prosedur dalam sistem bebas untuk memanggil yang lain, jika yang terakhir memberikan beberapa perhitungan yang berguna bahwa yang pertama kebutuhan. Mampu memanggil prosedur apa pun yang Anda inginkan sangat efisien, tetapi memiliki ribuan prosedur yang dapat memanggil satu sama lain tanpa batasan juga dapat menyebabkan sistem yang rumit dan sulit dipahami. Juga, crash di salah satu dari ini prosedur akan mencatat seluruh sistem operasi.

Untuk membangun program objek aktual dari sistem operasi ketika pendekatan ini digunakan, pertama-tama yang pertama mengkompilasi semua prosedur individu (atau file yang berisi prosedur) dan kemudian mengikat semuanya menjadi satu executable tunggal.

file menggunakan tautan sistem. Dalam hal menyembunyikan informasi, pada dasarnya ada none—setiap prosedur terlihat oleh setiap prosedur lainnya (berlawanan dengan struktur yang berisi modul atau paket, di mana sebagian besar informasi disembunyikan aw ay di dalam modul, dan hanya titik masuk yang ditunjuk secara resmi yang dapat dipanggil dari luar modul).

Bahkan dalam sistem monolitik, bagaimanapun, adalah mungkin untuk memiliki beberapa struktur. Itu layanan (panggilan sistem) yang disediakan oleh sistem operasi diminta dengan menempatkan parameter di tempat yang ditentukan dengan baik (misalnya, di tumpukan) dan kemudian mengeksekusi jebakan petunjuk. Instruksi ini mengalihkan mesin dari mode pengguna ke mode kernel dan mentransfer kontrol ke sistem operasi, ditunjukkan sebagai langkah 6 pada Gambar. 1-17. Itu sistem operasi kemudian mengambil parameter dan menentukan panggilan sistem mana yang untuk dilaksanakan. Setelah itu, indeks ke dalam tabel yang berisi di slot k pointer ke prosedur yang melakukan panggilan sistem k (langkah 7 pada Gambar 1-17).

Organisasi ini menyarankan struktur dasar untuk sistem operasi:
1. Program utama yang memanggil prosedur layanan yang diminta.
2. Seperangkat prosedur layanan yang melakukan panggilan sistem.
3. Seperangkat prosedur utilitas yang membantu prosedur pelayanan.

Dalam model ini, untuk setiap panggilan sistem ada satu prosedur layanan yang menangani itu dan mengeksekusinya. Prosedur utilitas melakukan hal-hal yang diperlukan oleh beberapa prosedur layanan, seperti mengambil data dari program pengguna. Divisi ini prosedur menjadi tiga lapisan ditunjukkan pada Gambar. 1-24.

Selain sistem operasi inti yang dimuat saat komputer boot, banyak sistem operasi mendukung ekstensi yang dapat dimuat, seperti perangkat I/O driver dan sistem file. Komponen ini dimuat sesuai permintaan. Di UNIX mereka disebut perpustakaan bersama. Di Windows mereka disebut DLL (Dynamic-Link Perpustakaan). Mereka memiliki ekstensi file .dll dan direktori C:\Windows\system32 pada sistem Windows memiliki lebih dari 1000 dari mereka.

![image](https://user-images.githubusercontent.com/112523858/189551562-c009beaf-7f60-4571-ae42-c5fe5b9866ea.png)

Gambar 1-24. Model penataan sederhana untuk sistem monolitik.

### 1.7.2 Sistem Berlapis

Sebuah generalisasi dari pendekatan Gambar 1-24 adalah untuk mengatur sistem operasi sebagai hierarki lapisan, masing-masing dibangun di atas yang di bawahnya. Pertama Sistem yang dibangun dengan cara ini adalah sistem THE yang dibangun di sekolah Technische Hoge Eindhoven di Belanda oleh E. W. Dijkstra (1968) dan murid-muridnya. Sistem THE adalah sistem batch sederhana untuk komputer Belanda, Electrolog ica X8, yang memiliki 32K kata 27-bit (bit mahal saat itu).

Sistem ini memiliki enam lapisan, seperti yang ditunjukkan pada Gambar 1-25. Lapisan 0 berurusan dengan alokasi prosesor, beralih di antara proses ketika interupsi terjadi atau pengatur waktu kedaluwarsa. Di atas lapisan 0, sistem terdiri dari proses berurutan, masing-masing yang dapat diprogram tanpa harus khawatir tentang fakta bahwa banyak proses berjalan pada satu prosesor. Dengan kata lain, layer 0 menyediakan multiprogramming dasar dari CPU.

| Layer | Function |
| ----------- | ---------- |
| 5 | The Operator |
| 4 | User Programs |
| 3 | Input/Output management |
| 2 | Operator-process communication | 
| 1 | Memory and drum mangement |
| 0 | Processor allocation and multiprogramming |

Gambar 1-25. Struktur sistem operasi THE.

Layer 1 melakukan manajemen memori. Ini mengalokasikan ruang untuk proses di main memori dan pada drum kata 512K yang digunakan untuk menyimpan bagian proses (halaman) untuk yang tidak ada ruang di memori utama. Di atas lapisan 1, proses tidak memiliki khawatir tentang apakah mereka ada di memori atau di drum; perangkat lunak lapisan 1 berhati-hati memastikan halaman dibawa ke memori pada saat mereka dibutuhkan dan disingkirkan saat tidak dibutuhkan.

Layer 2 menangani komunikasi antara setiap proses dan konsol operator (yaitu, pengguna). Di atas lapisan ini, setiap proses secara efektif memiliki konsol operatornya sendiri. Layer 3 menangani pengelolaan perangkat I/O dan buffering arus informasi ke dan dari mereka. Di atas lapisan 3 setiap proses dapat menangani perangkat I/O abstrak dengan properti bagus, bukan perangkat nyata dengan banyak pembohong pecu. Layer 4 adalah tempat program pengguna ditemukan. Mereka tidak harus khawatir tentang proses, memori, konsol, atau manajemen I/O. operator sistem proses terletak di lapisan 5.

Generalisasi lebih lanjut dari konsep layering hadir di MULTICS sistem. Alih-alih lapisan, MULTICS digambarkan memiliki serangkaian konsentris cincin, dengan bagian dalam lebih diistimewakan daripada bagian luar (yang secara efektif adalah hal yang sama). Ketika sebuah prosedur di cincin luar ingin memanggil prosedur di cincin dalam, itu harus membuat setara dengan panggilan sistem, yaitu, instruksi TRAP yang parameternya diperiksa dengan cermat validitasnya sebelum panggilan diizinkan untuk dilanjutkan. Meskipun seluruh sistem operasi adalah bagian dari ruang alamat setiap proses pengguna di MULTICS, perangkat keras memungkinkan untuk menunjuk prosedur individu (segmen memori, sebenarnya) sebagai yang dilindungi terhadap membaca, menulis, atau mengeksekusi.

Padahal skema THE layering sebenarnya hanya sebagai bantuan desain, karena semua bagian dari sistem pada akhirnya dihubungkan bersama menjadi satu program yang dapat dieksekusi, di MULTICS, mekanisme cincin sangat banyak hadir pada waktu berjalan dan diterapkan oleh perangkat keras. Keuntungan dari mekanisme cincin adalah dapat dengan mudah diperluas ke struktur subsistem pengguna. Misalnya, seorang profesor dapat menulis program untuk menguji dan menilai program siswa dan menjalankan program ini di ring n, dengan program siswa berjalan di ring n + 1 sehingga mereka tidak dapat mengubahnya nilai.

### 1.7.3 Mikrokernel

Dengan pendekatan berlapis, desainer memiliki pilihan di mana menggambar batas kernel-pengguna. Secara tradisional, semua lapisan masuk ke dalam kernel, tapi itu tidak diperlukan. Faktanya, kasus yang kuat dapat dibuat untuk menempatkan sesedikit mungkin dalam mode kernel karena bug di kernel dapat menurunkan sistem secara instan. Sebaliknya, proses pengguna dapat diatur untuk memiliki daya yang lebih kecil sehingga bug mungkin tidak ada fatal.

Berbagai peneliti telah berulang kali mempelajari jumlah bug per 1000 baris kode (misalnya, Basilli dan Perricone, 1984; dan Ostrand dan Weyuker, 2002). Serangga kepadatan tergantung pada ukuran modul, usia modul, dan banyak lagi, tetapi angka rata-rata untuksistem industri yang serius adalah antara dua dan sepuluh bug per seribu baris kode. Ini berarti bahwa sistem operasi monolitik dengan lima juta baris kode kemungkinan mengandung antara 10.000 dan 50.000 bug kernel. Tidak semua ini berakibat fatal, tentu saja tentu saja, karena beberapa bug mungkin seperti mengeluarkan pesan kesalahan yang salah di a situasi yang jarang terjadi. Namun demikian, sistem operasi cukup buggy bahwa pabrikan komputer memasang tombol reset (seringkali di panel depan), sesuatu yang tidak dilakukan oleh produsen perangkat TV, stereo, dan mobil, meskipun sejumlah besar perangkat lunak di perangkat ini.

Ide dasar di balik desain mikrokernel adalah untuk mencapai keandalan yang tinggi denganmembagi sistem operasi menjadi modul kecil yang terdefinisi dengan baik, hanya satu dari yang—mikrokernel—berjalan dalam mode kernel dan sisanya berjalan sebagai proses pengguna biasa yang relatif lebih bertenaga. Secara khusus, dengan menjalankan setiap driver perangkat dan file sistem sebagai proses pengguna yang terpisah, bug di salah satunya dapat merusak komponen itu, tetapi tidak dapat membuat crash seluruh sistem. Dengan demikian bug pada driver audio akan menyebabkan suara menjadi kacau atau berhenti, tetapi tidak akan membuat komputer crash. Sebaliknya, dalam sistem monolitik dengan semua driver di kernel, driver audio kereta dapat dengan mudah mereferensikan alamat memori yang tidak valid dan menghentikan sistem secara instan.

Banyak mikrokernel telah diimplementasikan dan digunakan selama beberapa dekade (Haertig dkk., 1997; Heiser dkk., 2006; Herder dkk., 2006; Hildebrand, 1992; Kirsch et al., 2005; Liedtke, 1993, 1995, 1996; Pike dkk., 1992; dan Zuberi et al., 1999). Dengan pengecualian OS X, yang didasarkan pada mikrokernel Mach (Accetta et al., 1986), sistem operasi desktop umum tidak menggunakan mikrokernel. Namun, mereka dominan dalam aplikasi real-time, industri, avionik, dan militer yang misi kritis dan memiliki persyaratan keandalan yang sangat tinggi. Beberapa mikrokernel paling terkenal termasuk Integrity, K42, L4, PikeOS, QNX, Symbian, dan MINIX 3. Kami sekarang memberikan gambaran singkat tentang MINIX 3, yang mengambil ide dari modularitas hingga batasnya, memecah sebagian besar sistem operasi menjadi beberapa proses mode pengguna yang independen. MINIX 3 adalah sumber terbuka yang sesuai dengan POSIXsistem tersedia secara bebas di www.minix3.org (Giuffrida et al., 2012; Giuffrida et al.,2013; Herder dkk., 2006; Herder dkk., 2009; dan Hruby et al., 2013). 

Mikrokernel MINIX 3 hanya sekitar 12.000 baris C dan sekitar 1400 baris assembler untuk fungsi tingkat yang sangat rendah seperti menangkap interupsi dan switching proses. Kode C mengelola dan menjadwalkan proses, menangani antarproses komunikasi (dengan melewatkan pesan antar proses), dan menawarkan serangkaian 40 panggilan kernel untuk memungkinkan sistem operasi lainnya melakukan tugasnya. Panggilan ini melakukan fungsi seperti mengaitkan penangan ke interupsi, memindahkan data di antara ruang iklan, dan memasang peta memori untuk proses baru. Struktur proses dari MINIX 3 ditunjukkan pada Gambar. 1-26, dengan penangan panggilan kernel berlabel Sys. Itu driver perangkat untuk jam juga ada di kernel karena penjadwal berinteraksi erat dengan itu. Driver perangkat lain berjalan sebagai proses pengguna yang terpisah.

Di luar kernel, sistem terstruktur sebagai tiga lapisan proses yang semuanya berjalan dalam mode pengguna. Lapisan terendah berisi driver perangkat. Sejak mereka berlari masuk mode pengguna, mereka tidak memiliki akses fisik ke ruang port I/O dan tidak dapat mengeluarkan Perintah I/O secara langsung. Sebagai gantinya, untuk memprogram perangkat I/O, driver membangun struktur yang memberi tahu nilai mana yang akan ditulis ke port I/O mana dan membuat pemanggilan kernel.

![image](https://user-images.githubusercontent.com/112523858/189551692-cec1473a-b836-48dd-886b-ab4279967c9a.png)

Gambar 1-26. Struktur sederhana dari sistem MINIX.

kernel untuk melakukan penulisan. Pendekatan ini berarti bahwa kernel dapat memeriksa untuk melihat bahwa driver sedang menulis (atau membaca) dari I/O yang diizinkan untuk digunakan. Akibatnya (dan tidak seperti desain monolitik), driver audio buggy tidak dapat menulis secara tidak sengaja disk. Di atas driver adalah lapisan mode pengguna lain yang berisi server, yang melakukan sebagian besar pekerjaan sistem operasi. Satu atau lebih file server mengelola file sistem, manajer proses membuat, menghancurkan, dan mengelola proses, dan sebagainya pada. Program pengguna memperoleh layanan sistem operasi dengan mengirimkan pesan singkat ke server meminta panggilan sistem POSIX. Misalnya, suatu proses perlu `do a read` mengirim pesan ke salah satu file server yang memberitahukan apa yang harus dibaca.

Salah satu server yang menarik adalah server reinkarnasi, yang tugasnya adalah memeriksa apakah server dan driver lain berfungsi dengan benar. Dalam hal yang salah adalah terdeteksi, secara otomatis diganti tanpa campur tangan pengguna. Lewat sini, sistem penyembuhan diri dan dapat mencapai keandalan yang tinggi. Sistem memiliki banyak batasan yang membatasi kekuatan setiap proses. Seperti disebutkan, driver hanya dapat menyentuh port I/O resmi, tetapi akses ke panggilan kernel juga dikendalikan pada basis per-proses, seperti kemampuan untuk mengirim pesan ke proses lain. Proses juga dapat memberikan izin terbatas untuk proses lain untuk memiliki kernel mengakses ruang alamat mereka. Sebagai contoh, sistem file dapat memberikan izin untuk driver disk untuk membiarkan kernel menempatkan blok disk yang baru dibaca pada lokasi tertentu. alamat dalam ruang alamat sistem file. Jumlah total dari semua batasan ini adalah bahwa setiap driver dan server memiliki kekuatan yang tepat untuk melakukan pekerjaannya dan tidak ada apa-apa lebih, sehingga sangat membatasi kerusakan yang dapat dilakukan komponen kereta.

Gagasan yang agak terkait dengan memiliki kernel minimal adalah dengan meletakkan mekanisme untuk melakukan sesuatu di kernel tetapi bukan kebijakan. Untuk membuat poin ini lebih baik, mempertimbangkan penjadwalan proses. Sebuah algoritma penjadwalan yang relatif sederhana adalah untuk menetapkan prioritas numerik untuk setiap proses dan kemudian menjalankan kernel proses dengan prioritas tertinggi yang dapat dijalankan. Mekanismenya—di dalam kernel—adalah untuk cari proses dengan prioritas tertinggi dan jalankan. Kebijakan—menetapkan prioritas untuk proses—dapat dilakukan oleh proses mode pengguna. Dengan cara ini, kebijakan dan mekanisme dapat dipisahkan dan kernel dapat dibuat lebih kecil.

### 1.7.4 Model Server-Klien

Sedikit variasi dari ide mikrokernel adalah untuk membedakan dua kelas proses, server, yang masing-masing menyediakan beberapa layanan, dan klien, yang menggunakan layanan ini. Model ini dikenal sebagai model client-server. Seringkali yang terendah layer adalah mikrokernel, tetapi itu tidak diperlukan. Esensinya adalah adanya proses cli ent dan proses server. Komunikasi antara klien dan server sering melalui pesan lewat. Ke mendapatkan layanan, proses klien membangun pesan yang mengatakan apa yang diinginkannya dan mengirimkannya ke layanan yang sesuai. Layanan kemudian melakukan pekerjaan dan mengirim kembali jawabannya. Jika klien dan server kebetulan berjalan di mesin yang sama, pasti pengoptimalan dimungkinkan, tetapi secara konseptual, kita masih berbicara tentang pesan lewat di sini.

Generalisasi yang jelas dari ide ini adalah membuat klien dan server berjalan pada komputer yang berbeda, dihubungkan oleh jaringan lokal atau area luas, seperti yang digambarkan dalam Gambar 127. Karena klien berkomunikasi dengan server dengan mengirimkan pesan, klien tidak perlu mengetahui apakah pesan ditangani secara lokal pada mesin mereka sendiri, atau apakah pesan tersebut dikirim melalui jaringan ke server pada mesin jarak jauh. Sejauh menyangkut klien, hal yang sama terjadi dalam kedua kasus: permintaan adalah dikirim dan balasan kembali. Jadi model client-server adalah abstraksi yang dapat digunakan untuk satu mesin atau untuk jaringan mesin.

![image](https://user-images.githubusercontent.com/112523858/189551738-6838ed8e-294a-4c80-a6f1-1caca855a0ae.png)

Gambar 1-27. Model client-server melalui jaringan.

Semakin banyak sistem yang melibatkan pengguna di PC rumah mereka sebagai klien dan besar mesin di tempat lain berjalan sebagai server. Faktanya, sebagian besar Web mengoperasikan ini cara. PC mengirimkan permintaan untuk halaman Web ke server dan halaman Web datang kembali. Ini adalah penggunaan khas model client-server dalam jaringan.

### 1.7.5 Mesin Virtual

Rilis awal OS/360 adalah sistem batch yang ketat. Namun demikian, banyak Pengguna 360 ingin dapat bekerja secara interaktif di terminal, sehingga berbagai kelompok, baik di dalam maupun di luar IBM, memutuskan untuk menulis sistem pembagian waktu untuk itu. Sistem pembagian waktu resmi IBM, TSS/360, dikirimkan terlambat, dan ketika akhirnya tiba, sistem itu sangat besar dan lambat sehingga hanya sedikit situs yang mengonversinya. Itu akhirnya ditinggalkan setelah pengembangannya menghabiskan sekitar $ 50 juta (Graham, 1970). Tetapi sebuah kelompok di Pusat Ilmiah IBM di Cambridge, Massachusetts, menghasilkan sistem yang sangat berbeda yang akhirnya diterima IBM sebagai sebuah produk. Turunan liniernya, disebut z/VM, sekarang banyak digunakan pada mainframe IBM saat ini, Series, yang banyak digunakan di pusat data perusahaan besar, misalnya, sebagai server e-commerce yang menangani ratusan atau ribuan transaksi per detik dan menggunakan database yang ukurannya mencapai jutaan gigabyte.

**VM/370**

Sistem ini, awalnya bernama CP/CMS dan kemudian berganti nama menjadi VM/370 (Seawright dan MacKinnon, 1979), didasarkan pada pengamatan yang cerdik: sistem pembagian waktu menyediakan (1) multiprogramming dan (2) mesin yang diperluas dengan antarmuka yang lebih nyaman daripada perangkat keras biasa. Inti dari VM/370 adalah untuk sepenuhnya memisahkan kedua fungsi tersebut.

Jantung dari sistem, yang dikenal sebagai monitor mesin virtual, berjalan di perangkat keras kosong dan melakukan multiprogramming, menyediakan tidak hanya satu, tetapi beberapa mesin virtual ke lapisan berikutnya, seperti yang ditunjukkan pada Gambar. 1-28. Namun, tidak seperti semua sistem operasi lain, mesin virtual ini bukan mesin yang diperluas, dengan file dan fitur bagus lainnya. Sebaliknya, mereka adalah salinan persis dari perangkat keras kosong, termasuk mode kernel/pengguna, I/O, interupsi, dan segala sesuatu yang dimiliki mesin sebenarnya.

![image](https://user-images.githubusercontent.com/112523858/189551783-85ee90c1-675f-41ed-971a-557d483e8228.png)

Gambar 1-28. Struktur VM/370 dengan CMS.

Karena setiap mesin virtual identik dengan perangkat keras yang sebenarnya, masing-masing dapat menjalankan sistem operasi apa pun yang akan berjalan langsung pada perangkat keras kosong. Mesin virtual yang berbeda dapat, dan sering dilakukan, menjalankan sistem operasi yang berbeda. Pada sistem IBM VM/370 asli, beberapa menjalankan OS/360 atau salah satu dari kumpulan besar lainnya atau sistem operasi pemrosesan transaksi, sementara yang lain menjalankan pengguna tunggal, interaktif sistem yang disebut CMS (Conversational Monitor System) untuk pembagian waktu interaktif pengguna. Yang terakhir ini populer di kalangan programmer.

Ketika program CMS mengeksekusi panggilan sistem, panggilan itu terjebak ke sistem operasi di mesin virtualnya sendiri, bukan ke VM/370, seperti yang akan terjadi. berjalan di mesin nyata alih-alih yang virtual. CMS kemudian mengeluarkan normal instruksi I/O perangkat keras untuk membaca disk virtualnya atau apa pun yang diperlukan untuk melaksanakan panggilan. Instruksi I/O ini dijebak oleh VM/370, yang kemudian membentuknya sebagai bagian dari simulasi perangkat keras sebenarnya. Dengan benar-benar memisahkan fungsi multiprogramming dan menyediakan mesin yang diperluas, masing-masing potongan bisa lebih sederhana, lebih fleksibel, dan lebih mudah dirawat.

Dalam inkarnasi modernnya, z/VM biasanya digunakan untuk menjalankan beberapa sistem operasi lengkap daripada sistem pengguna tunggal seperti CMS. Misalnya, zSeries mampu menjalankan satu atau lebih mesin virtual Linux dengan sistem operasi IBM tradisional.

**Mesin Virtual Ditemukan Kembali**

Sementara IBM telah memiliki produk mesin virtual yang tersedia selama empat dekade, dan beberapa perusahaan lain, termasuk Oracle dan Hewlett-Packard, baru-baru ini menambahkan dukungan mesin virtual ke server perusahaan kelas atas mereka, gagasan virtualisasi sebagian besar telah diabaikan di dunia PC sampai saat ini. Tapi di masa lalu beberapa tahun, kombinasi kebutuhan baru, perangkat lunak baru, dan teknologi baru telah digabungkan untuk menjadikannya topik hangat.

Pertama kebutuhan. Banyak perusahaan secara tradisional menjalankan server email mereka, Web server, server FTP, dan server lain pada komputer yang terpisah, terkadang dengan sistem operasi yang berbeda. Mereka melihat virtualisasi sebagai cara untuk menjalankan semuanya di mesin yang sama tanpa crash satu server menurunkan sisanya.

Virtualisasi juga populer di dunia web hosting. Tanpa virtualisasi, Pelanggan hosting web dipaksa untuk memilih antara hosting bersama (yang hanya memberi mereka akun login di server Web, tetapi tidak ada kontrol atas perangkat lunak server) dan hosting khusus (yang memberi mereka mesin mereka sendiri, yang sangat fleksibel tetapi tidak hemat biaya untuk Situs Web kecil hingga menengah). Ketika sebuah web hosting perusahaan menawarkan mesin virtual untuk disewa, satu mesin fisik dapat menjalankan banyak mesin virtual, yang masing-masing tampak seperti mesin yang lengkap. Pelanggan yang menyewa mesin virtual dapat menjalankan sistem operasi dan perangkat lunak apa pun yang mereka inginkan untuk, tetapi dengan biaya yang lebih murah dari dedicated server (karena fisik yang sama mesin mendukung banyak mesin virtual secara bersamaan).

Kegunaan lain dari virtualisasi adalah untuk pengguna akhir yang ingin dapat menjalankan dua atau lebih banyak sistem operasi pada saat yang sama, katakanlah Windows dan Linux, karena beberapa paket aplikasi favorit mereka berjalan di satu dan beberapa berjalan di yang lain. Ini situasi diilustrasikan pada Gambar. 1-29 (a), di mana istilah "monitor mesin virtual" telah berganti nama menjadi hypervisor tipe 1, yang umum digunakan saat ini karena "monitor mesin virtual" membutuhkan lebih banyak penekanan tombol daripada yang disiapkan orang tahan dengan sekarang. Perhatikan bahwa banyak penulis menggunakan istilah tersebut secara bergantian.

![image](https://user-images.githubusercontent.com/112523858/189551848-1763ac43-7818-416d-a85f-7480f6fa0e71.png)

Gambar 1-29. (a) Sebuah hypervisor tipe 1. (b) Hypervisor tipe 2 murni. (c) Sebuah hypervisor tipe 2 yang praktis.

Meskipun tidak ada yang membantah daya tarik mesin virtual saat ini, masalahnya kemudian adalah implementasi. Untuk menjalankan perangkat lunak mesin virtual di komputer, CPU-nya harus dapat divirtualisasikan (Popek dan Goldberg, 1974). Singkatnya, ini dia masalah. Ketika sistem operasi berjalan pada mesin virtual (di user mode) mengeksekusi instruksi istimewa, seperti memodifikasi PSW atau melakukan I/O, adalah penting bahwa perangkap perangkat keras ke monitor mesin virtual sehingga instruksi dapat ditiru dalam perangkat lunak. Pada beberapa CPU—terutama Pentium, pendahulunya, dan klonnya—berusaha mengeksekusi instruksi yang diistimewakan dalam mode pengguna diabaikan begitu saja. Properti ini tidak memungkinkan untuk memiliki mesin virtual di sini hardware, yang menjelaskan kurangnya minat di dunia x86. Tentu saja, ada adalah penerjemah untuk Pentium, seperti Bochs, yang berjalan di Pentium, tetapi dengankehilangan kinerja satu hingga dua kali lipat, mereka tidak berguna untuk pekerjaan yang serius.

Situasi ini berubah sebagai akibat dari beberapa proyek penelitian akademis di 1990-an dan tahun-tahun awal milenium ini, terutama Disco di Stanford (Bugnion et al., 1997) dan Xen di Universitas Cambridge (Barham et al., 2003). Penelitian ini makalah mengarah ke beberapa produk komersial (mis., VMware Workstation dan Xen) dan kebangkitan minat pada mesin virtual. Selain VMware dan Xen, populer hypervisor hari ini termasuk KVM (untuk kernel Linux), VirtualBox (oleh Oracle), dan Hyper-V (oleh Microsoft).

Beberapa proyek penelitian awal ini meningkatkan kinerja dibandingkan penerjemah seperti Bochs dengan menerjemahkan blok kode dengan cepat, menyimpannya dalam cache internal, dan kemudian menggunakannya kembali jika dieksekusi lagi. Ini meningkatkan kinerja jauh, dan menyebabkan apa yang kita sebut simulator mesin, sebagai ditunjukkan pada Gambar. 1-29 (b). Namun, meskipun teknik ini, yang dikenal sebagai terjemahan biner, membantu memperbaiki keadaan, sistem yang dihasilkan, meskipun cukup baik untuk mempublikasikan makalah tentang konferensi akademik, masih belum cukup cepat untuk digunakan dalam lingkungan komersial di mana kinerja sangat penting.

Langkah selanjutnya dalam meningkatkan kinerja adalah menambahkan modul kernel yang harus dilakukan beberapa pengangkatan berat, seperti ditunjukkan pada Gambar 1-29(c). Dalam praktiknya sekarang, semua hypervisor yang tersedia secara komersial, seperti VMware Workstation, menggunakan strategi hybrid ini (dan memiliki banyak perbaikan lainnya juga). Mereka disebut hypervisor tipe 2 oleh semua orang, jadi kami akan (agak enggan) mengikuti dan menggunakan nama ini di sisa buku ini, meskipun kami lebih suka menyebutnya hypervisor tipe 1.7 untuk mencerminkan fakta bahwa mereka tidak sepenuhnya program mode pengguna. Dalam Bab. 7, kita akan menjelaskan secara rinci cara kerja VMware Workstation dan apa saja variasinya potongan lakukan.

Dalam praktiknya, perbedaan nyata antara hypervisor tipe 1 dan hypervisor tipe 2 adalah bahwa tipe 2 menggunakan sistem operasi host dan sistem filenya untuk membuat proses, menyimpan file, dan sebagainya. Hypervisor tipe 1 tidak memiliki dukungan yang mendasari dan harus melakukan semua fungsi ini sendiri. Setelah hypervisor tipe 2 dimulai, ia membaca CD-ROM instalasi (atau file gambar CD ROM) untuk sistem operasi tamu yang dipilih dan menginstal OS tamu pada disk virtual, yang hanya merupakan file besar di sistem file sistem operasi host.

Hypervisor tipe 1 tidak dapat melakukan ini karena tidak ada sistem operasi host untuk menyimpan file di. Mereka harus mengelola penyimpanan mereka sendiri di partisi disk mentah. Ketika sistem operasi tamu di-boot, ia melakukan hal yang sama seperti pada perangkat keras yang sebenarnya, biasanya memulai beberapa proses latar belakang dan kemudian GUI. Bagi pengguna, sistem operasi tamu berperilaku sama seperti ketika berjalan di atas bare metal meskipun tidak demikian halnya di sini.

Pendekatan yang berbeda untuk menangani instruksi kontrol adalah dengan memodifikasi operasi sistem untuk menghapusnya. Pendekatan ini bukan virtualisasi sejati, tetapi isasi paravirtual. Kami akan membahas virtualisasi secara lebih rinci di Bab. 7.

**Mesin Virtual Java**

Area lain di mana mesin virtual digunakan, tetapi dengan cara yang agak berbeda cara, adalah untuk menjalankan program Java. Ketika Sun Microsystems menemukan bahasa pemrograman Java, ia juga menemukan mesin virtual (yaitu, arsitektur komputer) yang disebut JVM (Java Virtual Machine). Kompiler Java menghasilkan kode untuk JVM, yang kemudian biasanya dijalankan oleh penerjemah JVM perangkat lunak. Keuntungan dari pendekatan ini adalah bahwa kode JVM dapat dikirimkan melalui Internet ke komputer mana pun yang memiliki juru bahasa JVM dan dijalankan di sana. Jika kompiler telah menghasilkan program biner SPARC atau x86, misalnya, mereka tidak mungkin dikirim dan dijalankan di mana saja dengan mudah. (Tentu saja, Sun dapat menghasilkan kompiler yang menghasilkan biner SPARC dan kemudian mendistribusikan penerjemah SPARC, tetapi JVM adalah arsitektur yang jauh lebih sederhana untuk ditafsirkan.) Keuntungan lain menggunakan JVM adalah bahwa jika penerjemah diterapkan dengan benar, yang tidak sepenuhnya sepele, program JVM yang masuk dapat diperiksa keamanannya dan kemudian dieksekusi di lingkungan yang dilindungi sehingga tidak dapat mencuri data atau melakukan kerusakan apa pun.

### 1.7.6 Eksokernel

Daripada mengkloning mesin yang sebenarnya, seperti yang dilakukan dengan mesin virtual, strategi lain adalah mempartisinya, dengan kata lain, memberi setiap pengguna subset dari sumber daya. Jadi satu mesin virtual mungkin mendapatkan blok disk 0 hingga 1023, yang berikutnya mungkin mendapatkan blok 1024 hingga 2047, dan seterusnya.

Di lapisan bawah, berjalan dalam mode kernel, adalah sebuah program yang disebut exokernel (Engler et al., 1995). Tugasnya adalah mengalokasikan sumber daya ke mesin virtual dan kemudian periksa upaya untuk menggunakannya untuk memastikan tidak ada mesin yang mencoba menggunakan seseorang sumber daya lain. Setiap mesin virtual tingkat pengguna dapat menjalankan sistem operasinya sendiri, seperti pada VM/370 dan Pentium virtual 8086s, kecuali bahwa masing-masing dibatasi untuk hanya menggunakan sumber daya yang telah diminta dan telah dialokasikan. Keuntungan dari skema exokernel adalah menghemat lapisan pemetaan. Di desain lainnya, setiap mesin virtual menganggapnya memiliki disk sendiri, dengan blok berjalan dari 0 hingga maksimum, sehingga monitor mesin virtual harus mempertahankan tabel untuk memetakan ulang alamat disk (dan semua sumber daya lainnya). Dengan exokernel, ini pemetaan ulang tidak diperlukan. Exokernel hanya perlu melacak mesin virtual mana yang telah ditetapkan sumber dayanya. Cara ini masih memiliki keunggulan memisahkan multiprogramming (dalam exokernel) dari sistem operasi pengguna kode (di ruang pengguna), tetapi dengan overhead yang lebih sedikit, karena yang harus dilakukan exokernel adalah jauhkan mesin virtual dari rambut masing-masing.

## 1.8 DUNIA MENURUT C

Sistem operasi biasanya adalah program C (atau kadang-kadang C++) besar yang terdiri dari banyak bagian yang ditulis oleh banyak pemrogram. Lingkungan yang digunakan untuk mengembangkan sistem operasi sangat berbeda dari apa yang digunakan oleh individu (seperti siswa) ketika menulis program Java kecil. Bagian ini merupakan upaya untuk memberikan pengantar yang sangat singkat ke dunia penulisan sistem operasi untuk programmer Java atau Python waktu kecil.

### 1.8.1 Bahasa C

Ini bukan panduan untuk C, tetapi ringkasan singkat dari beberapa perbedaan utama antara C dan bahasa seperti Python dan terutama Java. Java didasarkan pada C, jadi banyak persamaan diantara keduanya. Python agak berbeda, tapi tetap saja cukup mirip. Untuk kenyamanan, kami fokus pada Java. Java, Python, dan C semuanya bahasa imperatif dengan tipe data, variabel, dan pernyataan kontrol, misalnya. Tipe data primitif dalam C adalah bilangan bulat (termasuk yang pendek dan panjang), karakter, dan angka floating-point. Tipe data komposit dapat dibangun menggunakan array, struktur, dan serikat pekerja. Pernyataan kontrol dalam C mirip denganyang ada di Java, termasuk pernyataan if, switch, for, dan while. Fungsi dan parameter kurang lebih sama dalam kedua bahasa.

Salah satu fitur C yang tidak dimiliki Java dan Python adalah pointer eksplisit. Sebuah penunjuk adalah variabel yang menunjuk ke (yaitu, berisi alamat) variabel atau struktur data.

Perhatikan pernyataan

karakter c1, c2, *p;

c1 = 'c';

p = &c1;

c2 = *p;

yang mendeklarasikan c1 dan c2 sebagai variabel karakter dan p sebagai variabel yang menunjuk untuk (yaitu, berisi alamat) karakter. Tugas pertama menyimpan ASCII kode untuk karakter "c" dalam variabel c1. Yang kedua memberikan alamat dari c1 ke variabel pointer p. Yang ketiga menetapkan isi variabel ditunjuk oleh p ke variabel c2, jadi setelah pernyataan ini dieksekusi, c2 juga berisi kode ASCII untuk ''c''. Secara teori, pointer diketik, jadi Anda tidak seharusnya menetapkan alamat nomor floating-point ke pointer karakter, tetapi dalam kompiler praktik menerima tugas seperti itu, meskipun terkadang dengan peringatan.

Pointer adalah konstruksi yang sangat kuat, tetapi juga merupakan sumber kesalahan yang hebat saat digunakan sembarangan. Beberapa hal yang tidak dimiliki C termasuk string, utas, paket, kelas, objek, keamanan tipe, dan pengumpulan sampah. Yang terakhir adalah penghenti pertunjukan untuk sistem operasi. Semua penyimpanan di C dialokasikan secara statis atau eksplisit dan dirilis oleh programmer, biasanya dengan fungsi library malloc dan gratis. Dia adalah properti terakhir — kontrol programmer total atas memori — bersama dengan eksplisit pointer yang membuat C menarik untuk menulis sistem operasi. Sistem operasi pada dasarnya adalah sistem waktu nyata sampai batas tertentu, bahkan untuk tujuan umum. Kapan interupsi terjadi, sistem operasi mungkin hanya memiliki beberapa mikrodetik untuk melakukan beberapa tindakan atau kehilangan informasi penting. Memiliki tendangan pengumpul sampah di saat yang sewenang-wenang tidak dapat ditoleransi.

### 1.8.2 File Tajuk

Sebuah proyek sistem operasi umumnya terdiri dari sejumlah direktori, masing-masing berisi banyak file .c yang berisi kode untuk beberapa bagian sistem, bersama dengan beberapa file header .h yang berisi deklarasi dan definisi yang digunakan oleh satu atau lebih file kode. File header juga dapat menyertakan makro sederhana, seperti #tentukan UKURAN BUFFER 4096 yang memungkinkan programmer untuk memberi nama konstanta, sehingga ketika BUFFER SIZE adalah digunakan dalam kode, itu diganti selama kompilasi dengan nomor 4096. Baik C praktik pemrograman adalah memberi nama setiap konstanta kecuali 0, 1, dan 1, dan beberapa kali bahkan mereka. Makro dapat memiliki parameter, seperti

#define max(a, b) (a > b ? a : b)

yang memungkinkan programmer untuk menulis

i = maks(j, k+1)

dan dapatkan

i = (j > k+1 ? j : k+1)

untuk menyimpan yang lebih besar dari j dan k+1 di i. Header juga dapat berisi kompilasi bersyarat, misalnya

#ifdef X86

int int ack();

- berakhir jika yang dikompilasi menjadi panggilan ke fungsi intel int ack jika makro X86 didefinisikan dan tidak ada yang sebaliknya. Kompilasi bersyarat banyak digunakan untuk mengisolasi kode yang bergantung pada arsitektur sehingga kode tertentu dimasukkan hanya ketika sistem dikompilasi pada X86, kode lain dimasukkan hanya ketika sistem dikompilasi pada SPARK, dan sebagainya. File .c dapat secara fisik menyertakan nol atau lebih file header menggunakan
- sertakan arahan. Ada juga banyak file header yang umum untuk hampir setiap .c dan disimpan dalam direktori pusat.

### 1.8.3 Proyek Pemrograman Besar

Untuk membangun sistem operasi, setiap .c dikompilasi menjadi file objek oleh C penyusun. File objek, yang memiliki akhiran .o, berisi instruksi biner untuk mesin sasaran. Mereka nantinya akan langsung dieksekusi oleh CPU. Tidak ada apa-apa seperti kode byte Java atau kode byte Python di dunia C.

Pass pertama dari compiler C disebut preprocessor C. Saat membaca masing-masing .c file, setiap kali mengenai direktif #include, ia pergi dan mendapatkan file header bernama di dalamnya dan memprosesnya, memperluas makro, menangani kompilasi bersyarat (dan hal-hal tertentu lainnya) dan meneruskan hasilnya ke pass kompiler berikutnya seolah-olah mereka secara fisik disertakan.

Karena sistem operasi sangat besar (lima juta baris kode tidak tidak biasa), harus mengkompilasi ulang semuanya setiap kali satu file diubah akan menjadi tak tertahankan. Di sisi lain, mengubah file header kunci yang disertakan dalam ribuan file lain memang membutuhkan kompilasi ulang file-file itu. Melacak file objek mana yang bergantung pada file header mana yang benar-benar tidak dapat dikelola tanpa bantuan.

Untungnya, komputer sangat pandai dalam hal semacam ini. Di UNIX sistem, ada program yang disebut make (dengan banyak varian seperti gmake, pmake, dll.) yang membaca Makefile, yang memberi tahu file mana yang bergantung pada file lain yang mana. Apa yang dilakukan adalah melihat file objek mana yang diperlukan untuk membangun biner sistem operasi dan untuk masing-masing, periksa untuk melihat apakah ada file yang bergantung on (kode dan header) telah dimodifikasi setelah terakhir kali file objek dibuat. Jika demikian, file objek itu harus dikompilasi ulang. Ketika membuat memiliki menentukan file .c mana yang harus dikompilasi ulang, ia kemudian memanggil kompiler C untuk mengkompilasi ulang mereka, sehingga mengurangi jumlah kompilasi ke minimum.

Dalam proyek besar, membuat Makefile rawan kesalahan, jadi ada alat yang melakukannya secara otomatis. Setelah semua file .o siap, mereka diteruskan ke program yang disebut linker to menggabungkan semuanya menjadi satu file biner yang dapat dieksekusi. Setiap fungsi perpustakaan yang dipimpin juga disertakan pada titik ini, referensi interfungsi diselesaikan, dan alamat mesin dipindahkan sesuai kebutuhan. Ketika linker selesai, hasilnya adalah program yang dapat dieksekusi, secara tradisional disebut a.out pada sistem UNIX. Berbagai komponen dari proses ini diilustrasikan pada Gambar 1-30 untuk program dengan tiga C file dan dua file header. Meskipun kami telah membahas pengembangan sistem operasi di sini, semua ini berlaku untuk mengembangkan program besar apa pun.

![image](https://user-images.githubusercontent.com/112523858/189551991-2a60a1ff-83fa-4846-aa4c-25c733966e3d.png)

Gambar 1-30. Proses kompilasi file C dan header untuk membuat executable.

### 1.8.4 Model Waktu Berjalan

Setelah biner sistem operasi telah dihubungkan, komputer dapat reboot dan sistem operasi baru dimulai. Setelah berjalan, mungkin secara dinamis memuat potongan yang tidak disertakan secara statis dalam biner seperti driver perangkat dan sistem file. Pada saat dijalankan sistem operasi dapat terdiri dari beberapa segmen, untuk teks (kode program), data, dan tumpukan. Segmen teks adalah biasanya tidak berubah, tidak berubah selama eksekusi. Segmen data dimulai pada ukuran tertentu dan diinisialisasi dengan nilai tertentu, tetapi dapat berubah dan tumbuh sebagai perlu. Tumpukan awalnya kosong tetapi tumbuh dan menyusut saat fungsi disebut dan kembali dari. Seringkali segmen teks ditempatkan di dekat bagian bawah memori, segmen data tepat di atasnya, dengan kemampuan untuk tumbuh ke atas, dan segmen tumpukan pada alamat virtual yang tinggi, dengan kemampuan untuk tumbuh ke bawah, tetapi berbeda sistem bekerja secara berbeda.

Dalam semua kasus, kode sistem operasi dijalankan langsung oleh perangkat keras, tanpa penerjemah dan kompilasi just-in-time, seperti biasa dengan Java.

## 1.9 PENELITIAN SISTEM OPERASI

Ilmu komputer adalah bidang yang berkembang pesat dan sulit untuk memprediksi di mana itu sedang pergi. Para peneliti di universitas dan laboratorium penelitian industri terus-menerus memikirkan ide-ide baru, beberapa di antaranya pergi ke mana-mana tetapi beberapa di antaranya menjadi landasan produk masa depan dan memiliki dampak besar pada industri dan pengguna. Mengatakan mana yang ternyata lebih mudah dilakukan di belakang daripada secara real time. Memisahkan gandum dari sekam sangat sulit karena seringkali membutuhkan waktu 20 hingga 30 tahun dari ide hingga dampak.

Misalnya, ketika Presiden Eisenhower mendirikan Badan Proyek Penelitian Lanjutan Departemen Pertahanan (ARPA) pada tahun 1958, ia berusaha untuk mempertahankan Tentara dari membunuh Angkatan Laut dan Angkatan Udara atas anggaran penelitian Pentagon. Dia tidak mencoba untuk menciptakan Internet. Tapi salah satu hal yang ARPA lakukan adalah mendanai beberapa penelitian universitas tentang konsep packet switching yang saat itu tidak jelas, yang mengarah ke jaringan packet-switched eksperimental pertama, ARPANET. Dia diluncurkan pada tahun 1969. Tak lama kemudian, jaringan penelitian lain yang didanai ARPA terhubung ke ARPANET, dan Internet pun lahir. Internet kemudian dengan senang hati digunakan oleh peneliti akademis untuk mengirim email satu sama lain selama 20 tahun. Dalam awal 1990-an, Tim Berners-Lee menemukan World Wide Web di penelitian CERN lab di Jenewa dan Marc Andreesen menulis browser grafis untuk itu di Universitas Illinois. Tiba-tiba Internet penuh dengan remaja yang berkicau. Presiden Eisenhower mungkin berguling di kuburannya.

Penelitian dalam sistem operasi juga telah menyebabkan perubahan dramatis dalam praktik sistem. Seperti yang telah kita diskusikan sebelumnya, sistem komputer komersial pertama semuanya sistem batch, sampai M.I.T. menemukan pembagian waktu tujuan umum di awal 1960-an. Komputer semuanya berbasis teks sampai Doug Engelbart menemukan mouse dan antarmuka pengguna grafis di Stanford Research Institute pada akhir 1960-an.

_Siapa yang tahu apa yang akan datang selanjutnya?_

Di bagian ini dan di bagian yang sebanding di seluruh buku ini, kami akan mengambil melihat secara singkat beberapa penelitian dalam sistem operasi yang telah terjadi selama 5 hingga 10 tahun terakhir, hanya untuk memberi gambaran tentang apa yang mungkin ada di cakrawala. Ini pengenalan tentu tidak komprehensif. Hal ini sebagian besar didasarkan pada makalah yang memiliki telah diterbitkan di konferensi penelitian teratas karena ide-ide ini setidaknya memiliki selamat dari proses peer review yang ketat untuk diterbitkan. Perhatikan bahwa dalam ilmu komputer—berlawanan dengan bidang ilmiah lainnya—kebanyakan penelitian diterbitkan di konferensi, bukan di jurnal. Sebagian besar makalah yang dikutip di bagian penelitian adalah: diterbitkan oleh ACM, IEEE Computer Society, atau USENIX dan tersedia melalui Internet untuk (siswa) anggota organisasi ini. Untuk informasi lebih lanjut tentang organisasi ini dan perpustakaan digital mereka, lihat

- ACM http://www.acm.org
- IEEE Computer Society http://www.computer.org
- USENIX http://www.usenix.org

Hampir semua peneliti sistem operasi menyadari bahwa sistem operasi saat ini sangat besar, tidak fleksibel, tidak dapat diandalkan, tidak aman, dan sarat dengan bug, tertentu. yang lebih dari yang lain (nama dirahasiakan di sini untuk melindungi yang bersalah). Akibatnya, ada banyak penelitian tentang bagaimana membangun sistem operasi yang lebih baik. Pekerjaan baru-baru ini telah dipublikasikan tentang bug dan debugging (Renzelmann et al., 2012; dan Zhou et al al., 2012), pemulihan kecelakaan (Correia et al., 2012; Ma et al., 2013; Ongaro et al., 2011; dan Yeh dan Cheng, 2012), manajemen energi (Pathak et al., 2012; Pet rucci dan Loques, 2012; dan Shen et al., 2013), sistem file dan penyimpanan (Elnably dan Wang, 2012; Nightingale dkk., 2012; dan Zhang et al., 2013a), I/O kinerja tinggi (De Bruijn et al., 2011; Li et al., 2013a; dan Rizzo, 2012), hyper threading dan multithreading (Liu et al., 2011), pembaruan langsung (Giuffrida et al., 2013), mengelola GPU (Rossbach et al., 2011), manajemen memori (Jantz et al., 2013; dan Jeong et al., 2013), sistem operasi multicore (Baumann et al., 2009; Kaprit sos, 2012; Lachaize et al., 2012; dan Wentzlaff et al., 2012), sistem operasi yang benar (Elphinstone et al. al., 2007; Yang dkk., 2006; dan Klein dkk., 2009), keandalan sistem operasi (Hruby dkk., 2012; Ryzhyk dkk., 2009, 2011 dan Zheng dkk. al., 2012), privasi dan keamanan (Dunn et al., 2012; Giuffrida et al., 2012; Li et al., 2013b; Lorch dkk., 2013; Ortolani dan Crispo, 2012; Slowinska dkk., 2012; dan Ur et al., 2012), pemantauan penggunaan dan kinerja (Harter et al, 2012; dan Ravin dranath et al., 2012), dan virtualisasi (Agesen et al., 2012; Ben-Yehuda et al., 2010; Colp et al., 2011; Dai dkk., 2013; Tarasov dkk., 2013; dan Williams dkk., 2012) di antara banyak topik lainnya.

## 1.10 GARIS BESAR DARI BUKU INI

Kami sekarang telah menyelesaikan pengenalan kami dan pandangan menyeluruh tentang operasi sistem. Saatnya untuk turun ke rincian. Seperti yang sudah disebutkan, dari sudut pandang programmer, tujuan utama dari sistem operasi adalah untuk menyediakan beberapa abstraksi utama, yang paling penting adalah proses dan utas, ruang iklan, dan file. Dengan demikian, tiga bab berikutnya dikhususkan untuk ini topik kritis.

Bab 2 adalah tentang proses dan utas. Ini membahas properti mereka dan bagaimana mereka berkomunikasi satu sama lain. Ini juga memberikan sejumlah contoh terperinci tentang bagaimana komunikasi antarproses bekerja dan bagaimana menghindari beberapa perangkap. Dalam Bab. 3 kita akan mempelajari ruang alamat dan tambahannya, manajemen manajemen memori, secara rinci. Topik penting dari memori virtual akan diperiksa, bersama dengan konsep yang terkait erat seperti paging dan segmentasi. Kemudian, di Bab. 4, kita sampai pada topik yang sangat penting tentang sistem file. Sampai batas tertentu, apa yang dilihat pengguna sebagian besar adalah sistem file. Kami akan melihat keduanya antarmuka sistem file dan implementasi sistem file.

Input/Output dibahas dalam Bab. 5. Konsep kemandirian perangkat dan ketergantungan perangkat akan dilihat. Beberapa perangkat penting, termasuk disk, keyboard, dan tampilan, akan digunakan sebagai contoh. Bab 6 adalah tentang kebuntuan. Kami secara singkat menunjukkan apa kebuntuan dalam hal ini bab, tetapi ada banyak lagi yang bisa dikatakan. Cara untuk mencegah atau menghindarinya dibahas.

Pada titik ini kita akan menyelesaikan studi tentang prinsip-prinsip dasar sistem operasi CPU tunggal. Namun, ada lebih banyak yang bisa dikatakan, terutama tentang topik iklan. Dalam Bab. 7, kami memeriksa virtualisasi. Kami membahas kedua prinsip, dan beberapa solusi virtualisasi yang ada secara rinci. Karena virtualisasi banyak digunakan dalam komputasi awan, kami juga akan melihat awan yang ada.

Topik lanjutan lainnya adalah sistem multiprosesor, termasuk multicore, paralel komputer, dan sistem terdistribusi. Mata pelajaran ini tercakup dalam Bab. 8. Subjek yang sangat penting adalah keamanan sistem operasi, yang tercakup dalam

Bab 9. Di antara topik yang dibahas dalam bab ini adalah ancaman (misalnya, virus dan worm), mekanisme perlindungan, dan model keamanan. Selanjutnya kita memiliki beberapa studi kasus sistem operasi nyata. Ini adalah UNIX,Linux, dan Android (Bab 10), dan Windows 8 (Bab 11). Teks menyimpulkan
dengan beberapa kebijaksanaan dan pemikiran tentang desain sistem operasi di Bab. 12.

## 1.11 UNIT METRIK

Untuk menghindari kebingungan, ada baiknya menyatakan secara eksplisit bahwa dalam buku ini, seperti dalam ilmu komputer secara umum, unit metrik digunakan sebagai pengganti bahasa Inggris tradisional unit (sistem dua minggu batu-furlong). Awalan metrik utama terdaftar pada Gambar 1-31. Awalan biasanya disingkat dengan huruf pertama mereka, dengan unit lebih besar dari 1 dikapitalisasi. Jadi database 1-TB menempati 1012 byte dari usia penyimpanan dan jam 100-psec (atau 100-ps) berdetak setiap 10−10 detik. Sejak mili dan mikro keduanya dimulai dengan huruf "m", pilihan harus dibuat. Biasanya, "m" adalah untuk mili dan "μ" (huruf Yunani mu) adalah untuk mikro

| Exp. | Explicit | Prefix | Exp. | Explicit | Prefix |
| ----------- | :--------- | :----------: | ----------- | :--------- | :---------- |
| 10^-3 | 0.001 | milli | 10^3 | 1,000 | Kilo |
| 10^−6 | 0.000001 | micro | 10^6 | 1,000,000 | Mega |
| 10^−9 | 0.000000001 | nano | 10^9 | 1,000,000,000 | Giga |
| 10−12 | 0.000000000001 | pico |10^12 | 1,000,000,000,000 |Tera | 
| 10^−15 | 0.000000000000001 | femto | 10^15 | 1,000,000,000,000,000 | Peta |
| 10^−18 | 0.000000000000000001 | atto | 10^18 | 1,000,000,000,000,000,000 | Exa |
| 10^−21 | 0.000000000000000000001 | zepto | 10^21 | 1,000,000,000,000,000,000,000 | Zetta |
| 10^−24 | 0.000000000000000000000001 | yocto | 10^24 | 1,000,000,000,000,000,000,000,000 | Yotta |

Gambar 1-31. Awalan metrik utama.

Perlu juga ditunjukkan bahwa, dalam praktik industri umum, unit untuk mengukur ukuran memori memiliki arti yang sedikit berbeda. Ada kilo berarti 210 (1024) daripada 103 (1000) karena ingatan selalu merupakan kekuatan dua. Jadi Memori 1-KB berisi 1024 byte, bukan 1000 byte. Demikian pula, memori 1-MB berisi 220 (1.048.576) byte dan memori 1 GB berisi 230 (1.073.741.824) byte. Namun, jalur komunikasi 1-Kbps mentransmisikan 1000 bit per detik dan LAN 10-Mbps berjalan pada 10.000.000 bit/detik karena kecepatan ini bukan kekuatan dua. Sayangnya, banyak orang cenderung mencampuradukkan kedua sistem ini, terutama untuk ukuran disk. Untuk menghindari ambiguitas, dalam buku ini, kita akan menggunakan simbol KB, MB, dan GB untuk masing-masing 210, 220, dan 230 byte, dan simbol Kbps, Mbps, dan Gbps untuk 103, 106, dan 109 bit/detik, masing-masing.

## 1.12 RINGKASAN

Sistem operasi dapat dilihat dari dua sudut pandang: manajer sumber daya danmesin diperpanjang. Dalam tampilan manajer sumber daya, tugas sistem operasi adalah untuk mengelola bagian-bagian yang berbeda dari sistem secara efisien. Dalam tampilan mesin yang diperluas, tugas sistem adalah menyediakan abstraksi yang lebih nyaman untuk digunakan daripada mesin yang sebenarnya kepada pengguna. Ini termasuk proses, ruang alamat, dan file.

Sistem operasi memiliki sejarah panjang, mulai dari hari-hari ketika mereka menempatkan operator, hingga sistem multiprogramming modern. Sorotan termasuk sistem batch awal, sistem multiprogramming, dan sistem komputer pribadi. Karena sistem operasi berinteraksi erat dengan perangkat keras, beberapa pengetahuan perangkat keras komputer berguna untuk memahaminya. Komputer dibangun dari prosesor, memori, dan perangkat I/O. Bagian-bagian ini dihubungkan oleh bus.

Konsep dasar di mana semua sistem operasi dibangun adalah proses, manajemen memori, manajemen I/O, sistem file, dan keamanan. Masing-masing akan dibahas pada bab berikutnya.

Inti dari setiap sistem operasi adalah kumpulan panggilan sistem yang dapat ditanganinya. Ini memberi tahu apa yang sebenarnya dilakukan sistem operasi. Untuk UNIX, kami telah melihat empat kelompok panggilan sistem. Kelompok pertama panggilan sistem berhubungan dengan pembuatan dan penghentian proses. Kelompok kedua adalah untuk membaca dan menulis file. Ketiga grup adalah untuk manajemen direktori. Kelompok keempat berisi panggilan lain-lain.

Sistem operasi dapat disusun dalam beberapa cara. Yang paling umum adalah sebagai sistem monolitik, hierarki lapisan, mikrokernel, client-server, virtual mesin, atau exokernel.

**MASALAH**

1. Apa dua fungsi utama sistem operasi?
2. Dalam Bagian 1.4, sembilan jenis sistem operasi dijelaskan. Berikan daftar aplikasi untuk masing-masing sistem ini (satu per jenis sistem operasi).
3. Apa perbedaan antara sistem timesharing dan multiprogramming?
4. Untuk menggunakan memori cache, memori utama dibagi menjadi baris cache, biasanya 32 atau 64 byte panjang. Seluruh baris cache di-cache sekaligus. Apa keuntungan dari caching dan?<br>seluruh baris alih-alih satu byte atau kata sekaligus?
5. Pada komputer awal, setiap byte data yang dibaca atau ditulis ditangani oleh CPU (yaitu, tidak ada DMA). Apa implikasinya bagi multiprogramming?
6. Instruksi yang berhubungan dengan pengaksesan perangkat I/O biasanya merupakan instruksi yang diistimewakan, yaitu: adalah, mereka dapat dieksekusi dalam mode kernel tetapi tidak dalam mode pengguna. Berikan alasan mengapa ini instruksi diistimewakan.
7. Ide keluarga komputer diperkenalkan pada 1960-an dengan IBM System/360 mainframe. Apakah ide ini sekarang mati sebagai paku atau masih hidup?
8. Salah satu alasan GUI pada awalnya lambat untuk diadopsi adalah biaya perangkat keras yang dibutuhkan untuk mendukungnya. Berapa banyak RAM video yang diperlukan untuk mendukung 25-baris × 80-baris layar teks karakter monokrom? Berapa harga untuk peta bit warna 24-bit 1200 × 900-piksel? Berapa harga RAM ini pada harga 1980 ($5/KB)? Berapa sekarang?
9. Ada beberapa tujuan desain dalam membangun sebuah sistem operasi, misalnya resource pemanfaatan, ketepatan waktu, ketahanan, dan sebagainya. Berikan contoh dua tujuan desain yang mungkin bertentangan satu sama lain.
10. Apa perbedaan antara kernel dan mode pengguna? Jelaskan bagaimana memiliki dua yang berbeda mode membantu dalam merancang sistem operasi.
11. Disk 255 GB memiliki 65.536 silinder dengan 255 sektor per track dan 512 byte per detik. Berapa banyak piringan dan kepala yang dimiliki disk ini? Dengan asumsi silinder rata-rata mencari waktu 11 ms, delay rotasi rata-rata 7 msec dan kecepatan membaca 100 MB/sec, hitung waktu rata-rata yang diperlukan untuk membaca 400 KB dari satu sektor.
12. Manakah dari instruksi berikut yang hanya diperbolehkan dalam mode kernel?
(a) Nonaktifkan semua interupsi.
(b) Membaca jam waktu dalam sehari.
(c) Atur jam waktu dalam sehari.
(d) Mengubah peta memori.
13. Pertimbangkan sistem yang memiliki dua CPU, masing-masing CPU memiliki dua utas (hyperthreading). Misalkan tiga program, P0, P1, dan P2, dimulai dengan runtime 5, 10 dan 20 msec, masing-masing. Berapa lama waktu yang dibutuhkan untuk menyelesaikan eksekusi program-program ini? Asumsikan bahwa ketiga program 100% terikat CPU, jangan diblokir selama eksekusi, dan jangan ubah CPU setelah ditetapkan.
14. Komputer memiliki saluran pipa dengan empat tahap. Setiap tahap membutuhkan waktu yang sama untuk melakukannya bekerja, yaitu, 1 nsec. Berapa banyak instruksi per detik yang dapat dijalankan mesin ini?
15. Pertimbangkan sistem komputer yang memiliki memori cache, memori utama (RAM) dan disk, dan sistem operasi yang menggunakan memori virtual. Dibutuhkan 1 nsec untuk mengakses sebuah kata dari cache, 10 nsec untuk mengakses kata dari RAM, dan 10 ms untuk mengakses kata dari disk. Jika hit rate cache adalah 95% dan hit rate memori utama (setelah cache miss) adalah 99%, berapa waktu rata-rata untuk mengakses sebuah kata?
16. Ketika program pengguna membuat panggilan sistem untuk membaca atau menulis file disk, program tersebut menyediakan: indikasi file mana yang diinginkan, penunjuk ke buffer data, dan hitungan. Kontrol adalah kemudian ditransfer ke sistem operasi, yang memanggil driver yang sesuai. Memperkirakan bahwa driver memulai disk dan berhenti sampai terjadi interupsi. Dalam kasus membaca dari disk, jelas penelepon harus diblokir (karena ada tidak ada data untuk itu). Bagaimana dengan kasus menulis ke disk? Perlu penelepon diblokir menunggu penyelesaian transfer disk?
17. Apa itu instruksi jebakan? Jelaskan kegunaannya dalam sistem operasi!
18. Mengapa tabel proses dibutuhkan dalam sistem timesharing? Apakah itu juga diperlukan secara pribadi? sistem komputer yang menjalankan UNIX atau Windows dengan satu pengguna?
19. Apakah ada alasan mengapa Anda ingin memasang sistem file pada direktori yang tidak kosong? Jika demikian, apa itu?
20. Untuk setiap panggilan sistem berikut, berikan kondisi yang menyebabkannya gagal: fork, exec, dan batalkan tautan.
21. Jenis multiplexing (waktu, ruang, atau keduanya) apa yang dapat digunakan untuk berbagi berikut: sumber daya: CPU, memori, disk, kartu jaringan, printer, keyboard, dan tampilan?
22. Bisakah hitung = tulis(fd, buffer, nbytes); panggilan mengembalikan nilai apa pun dalam hitungan selain nbytes? Jika demikian, mengapa?
23. File yang deskriptor filenya adalah fd berisi urutan byte berikut: 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5. Panggilan sistem berikut dilakukan: lseek(fd, 3, MENCARI SET); baca(fd, &buffer, 4); di mana panggilan lseek melakukan pencarian ke byte 3 file. Apa yang mengandung buffer setelah bacaannya sudah selesai?
24. Misalkan file 10-MB disimpan pada disk pada track yang sama (track 50) di sektor-sektor berturut-turut. Lengan disk saat ini terletak di atas nomor trek 100. Berapa lama? diperlukan untuk mengambil file ini dari disk? Asumsikan bahwa dibutuhkan sekitar 1 ms untuk memindahkan lengan dari satu silinder ke silinder berikutnya dan sekitar 5 ms untuk sektor di mana awal file disimpan untuk diputar di bawah kepala. Juga, asumsikan bahwa membaca terjadi pada tingkat 200 MB/dtk.
25. Apa perbedaan penting antara file khusus blok dan karakter khusus? mengajukan?
26. Dalam contoh yang diberikan pada Gambar. 1-17, prosedur perpustakaan disebut membaca dan sistem panggilan itu sendiri disebut baca. Apakah penting bahwa keduanya memiliki nama yang sama? Jika tidak, mana yang lebih penting?
27. Sistem operasi modern memisahkan ruang alamat proses dari memori fisik mesin. Sebutkan dua keuntungan dari desain ini.
28. Untuk programmer, panggilan sistem terlihat seperti panggilan lain ke prosedur perpustakaan. Apakah itu penting bahwa seorang programmer mengetahui prosedur perpustakaan mana yang menghasilkan panggilan sistem? Dalam keadaan apa dan mengapa?
29. Gambar 1-23 menunjukkan bahwa sejumlah panggilan sistem UNIX tidak memiliki ekuivalen API Win32. Untuk setiap panggilan yang terdaftar sebagai tidak memiliki setara Win32, apa konsekuensi bagi seorang programmer untuk mengubah program UNIX untuk dijalankan di bawah Windows?
30. Sistem operasi portabel adalah sistem yang dapat di-porting dari satu arsitektur sistem ke lain tanpa modifikasi apapun. Jelaskan mengapa tidak layak untuk membangun sebuah operasi sistem yang benar-benar portabel. Jelaskan dua lapisan tingkat tinggi yang akan Anda miliki di merancang sistem operasi yang sangat portabel.
31. Jelaskan bagaimana pemisahan kebijakan dan mekanisme membantu dalam membangun berbasis mikrokernel sistem operasi.
32. Mesin virtual menjadi sangat populer karena berbagai alasan. Namun demikian, mereka memiliki beberapa kelemahan. Nama satu.
33. Berikut adalah beberapa pertanyaan untuk mempraktikkan konversi satuan:
(a) Berapa lama nanoyear dalam detik?
(b) Mikrometer sering disebut mikron. Berapa panjang megamikron?
(c) Berapa banyak byte yang ada dalam memori 1-PB?
(d) Massa bumi adalah 6000 yottagram. Apa itu dalam kilogram?
34. Tulislah sebuah shell yang mirip dengan Gambar 1-19 tetapi berisi kode yang cukup sehingga benar-benar berfungsi sehingga Anda dapat mengujinya. Anda juga dapat menambahkan beberapa fitur seperti pengalihan input dan output, pipa, dan pekerjaan latar belakang.
35. Jika Anda memiliki sistem pribadi seperti UNIX (Linux, MINIX 3, FreeBSD, dll.) tersedia bahwa Anda dapat crash dan reboot dengan aman, tulis skrip shell yang mencoba membuat jumlah proses anak yang tidak terbatas dan amati apa yang terjadi. Sebelum menjalankan percobaan, ketik sinkronisasi ke shell untuk menyiram buffer sistem file ke disk untuk menghindari merusak sistem file. Anda juga dapat melakukan eksperimen dengan aman di mesin virtual.
_Catatan: Jangan coba ini pada sistem bersama tanpa terlebih dahulu mendapatkan izin dari administrator sistem. Konsekuensinya akan langsung terlihat sehingga Anda kemungkinan besar akan tertangkap dan sanksi mungkin menyusul_
36. Periksa dan coba interpretasikan isi direktori mirip UNIX atau Windows dengan alat seperti program UNIX od. (Petunjuk: Bagaimana Anda melakukan ini akan tergantung pada apa OS memungkinkan. Salah satu trik yang mungkin berhasil adalah membuat direktori pada stik USB dengan satu sistem operasi dan kemudian membaca data perangkat mentah menggunakan sistem operasi berbeda yang memungkinkan akses tersebut.)

_**Salam dari Yuliana_2110131220001**_
"Terima Kasih"
